<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.51">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <script>
  var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?dontcopythisc696a0c7cf24973f0000f46233c";
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s); })();
  </script><title>操作系统 | 胡熙国</title><meta name="description" content="my blogs">
    <link rel="modulepreload" href="/assets/app.91a380bb.js"><link rel="modulepreload" href="/assets/system.html.2ee74b97.js"><link rel="modulepreload" href="/assets/system.html.451ba5da.js"><link rel="prefetch" href="/assets/index.html.87a08719.js"><link rel="prefetch" href="/assets/git.html.5347da4e.js"><link rel="prefetch" href="/assets/github.html.a3ca4742.js"><link rel="prefetch" href="/assets/CSS引入方式.html.93052126.js"><link rel="prefetch" href="/assets/CSS架构模式之BEM.html.072d564e.js"><link rel="prefetch" href="/assets/CSS样式优先级.html.c796a9bb.js"><link rel="prefetch" href="/assets/CSS盒子模型.html.986b5b58.js"><link rel="prefetch" href="/assets/CSS选择器.html.e8cda0f3.js"><link rel="prefetch" href="/assets/CSS隐藏元素的方法.html.373bd5f0.js"><link rel="prefetch" href="/assets/Flex布局.html.0286f1d8.js"><link rel="prefetch" href="/assets/Float浮动.html.2ad75993.js"><link rel="prefetch" href="/assets/Grid布局.html.6eb9ed50.js"><link rel="prefetch" href="/assets/Position定位.html.433b7fa6.js"><link rel="prefetch" href="/assets/index.html.a6515889.js"><link rel="prefetch" href="/assets/css.html.e73a4bd1.js"><link rel="prefetch" href="/assets/css3新特性.html.a6118693.js"><link rel="prefetch" href="/assets/实现三栏布局.html.89a21e7b.js"><link rel="prefetch" href="/assets/布局垂直居中.html.c85eed0d.js"><link rel="prefetch" href="/assets/index.html.a231195b.js"><link rel="prefetch" href="/assets/Cookie与Session.html.3fa73d68.js"><link rel="prefetch" href="/assets/DOM和BOM的区别.html.7a94ecf6.js"><link rel="prefetch" href="/assets/HTML5新特性.html.9e83baac.js"><link rel="prefetch" href="/assets/HTML语义化.html.985517ec.js"><link rel="prefetch" href="/assets/LocalStorage与SessionStorage.html.f6844dae.js"><link rel="prefetch" href="/assets/doctype.html.a04ea954.js"><link rel="prefetch" href="/assets/前端性能优化方案.html.673b4774.js"><link rel="prefetch" href="/assets/行内元素和块级元素.html.23f65cd7.js"><link rel="prefetch" href="/assets/index.html.f39321db.js"><link rel="prefetch" href="/assets/index.html.3ed64dad.js"><link rel="prefetch" href="/assets/GPIO.html.31f1963c.js"><link rel="prefetch" href="/assets/index.html.079aabfc.js"><link rel="prefetch" href="/assets/Serial.html.f21d4113.js"><link rel="prefetch" href="/assets/clock.html.57840570.js"><link rel="prefetch" href="/assets/index.html.9ad5ab8f.js"><link rel="prefetch" href="/assets/base.html.ffb8e27a.js"><link rel="prefetch" href="/assets/config.html.dac0844f.js"><link rel="prefetch" href="/assets/high_type.html.b2422c16.js"><link rel="prefetch" href="/assets/type.html.a8b8cdde.js"><link rel="prefetch" href="/assets/typeFile.html.69708a84.js"><link rel="prefetch" href="/assets/index.html.edec38f4.js"><link rel="prefetch" href="/assets/linux_command.html.451a0b5b.js"><link rel="prefetch" href="/assets/option.html.884793ef.js"><link rel="prefetch" href="/assets/初始化组件库.html.a83bde93.js"><link rel="prefetch" href="/assets/组件库工程化.html.26e10863.js"><link rel="prefetch" href="/assets/Array.html.971fac11.js"><link rel="prefetch" href="/assets/Destructuring.html.171abfdf.js"><link rel="prefetch" href="/assets/Object.html.0b6a16c6.js"><link rel="prefetch" href="/assets/Promise.html.9d287d5b.js"><link rel="prefetch" href="/assets/Prototype.html.d4814d40.js"><link rel="prefetch" href="/assets/guide1.html.9f96e005.js"><link rel="prefetch" href="/assets/index.html.3b6be33c.js"><link rel="prefetch" href="/assets/BOM对象.html.7066665f.js"><link rel="prefetch" href="/assets/cookie.html.ff4f4021.js"><link rel="prefetch" href="/assets/webWorker.html.f1ba1bda.js"><link rel="prefetch" href="/assets/apply-call-bind.html.494aa524.js"><link rel="prefetch" href="/assets/object属性.html.ce72bdf3.js"><link rel="prefetch" href="/assets/promise.html.38a8880a.js"><link rel="prefetch" href="/assets/sort.html.6dde1289.js"><link rel="prefetch" href="/assets/对象按要求填充数组.html.56a3468e.js"><link rel="prefetch" href="/assets/排序算法.html.62162a47.js"><link rel="prefetch" href="/assets/获取出现次数前三的tag.html.9bb78d65.js"><link rel="prefetch" href="/assets/连续赋值.html.ba4b5e44.js"><link rel="prefetch" href="/assets/动画.html.60c11fad.js"><link rel="prefetch" href="/assets/重绘和重排.html.a5d00b7d.js"><link rel="prefetch" href="/assets/2023-07-12.html.51ab5525.js"><link rel="prefetch" href="/assets/2023-07-19.html.3babb694.js"><link rel="prefetch" href="/assets/2023-07-20.html.710591a6.js"><link rel="prefetch" href="/assets/2023-07-25-fd.html.580eec2f.js"><link rel="prefetch" href="/assets/2023-07-25.html.cd78c83f.js"><link rel="prefetch" href="/assets/showmebug.html.42548f2b.js"><link rel="prefetch" href="/assets/常见面试题.html.a22f3c42.js"><link rel="prefetch" href="/assets/npmInstall.html.39878bf3.js"><link rel="prefetch" href="/assets/npm和yarn和pnpm对比.html.d54c46ea.js"><link rel="prefetch" href="/assets/ref-toRef-toRefs.html.05ac0c36.js"><link rel="prefetch" href="/assets/ref和reactive区别.html.ddbb994a.js"><link rel="prefetch" href="/assets/JS遍历对象.html.3cc23e3e.js"><link rel="prefetch" href="/assets/JS遍历数组.html.df0e09a2.js"><link rel="prefetch" href="/assets/addEventListener.html.ae971219.js"><link rel="prefetch" href="/assets/ajax.html.5dd13328.js"><link rel="prefetch" href="/assets/webworker.html.e1b1f9ab.js"><link rel="prefetch" href="/assets/严格模式.html.6ec4c5ec.js"><link rel="prefetch" href="/assets/函数式编程.html.e69872ee.js"><link rel="prefetch" href="/assets/判断数组的方法.html.2ac9c525.js"><link rel="prefetch" href="/assets/箭头函数和普通函数的区别.html.9e8f1d64.js"><link rel="prefetch" href="/assets/TCP-IP协议.html.d08e0803.js"><link rel="prefetch" href="/assets/TCP三次握手四次挥手.html.66bb7bbd.js"><link rel="prefetch" href="/assets/http状态码.html.5a5da3b1.js"><link rel="prefetch" href="/assets/node_tcp.html.e06c4152.js"><link rel="prefetch" href="/assets/node_udp.html.637f9286.js"><link rel="prefetch" href="/assets/网络请求.html.b3108af5.js"><link rel="prefetch" href="/assets/ES6新特性.html.1871e81b.js"><link rel="prefetch" href="/assets/JS变量提升.html.63151d84.js"><link rel="prefetch" href="/assets/Js模块化导入导出.html.2c209fbe.js"><link rel="prefetch" href="/assets/Js箭头函数.html.17877344.js"><link rel="prefetch" href="/assets/index.html.cc25895c.js"><link rel="prefetch" href="/assets/Symbol.html.dad80e3c.js"><link rel="prefetch" href="/assets/array.html.66d75954.js"><link rel="prefetch" href="/assets/copy.html.e302ee4a.js"><link rel="prefetch" href="/assets/data_type.html.301c2e17.js"><link rel="prefetch" href="/assets/defineProperty.html.76ba069d.js"><link rel="prefetch" href="/assets/eq.html.0d31d77a.js"><link rel="prefetch" href="/assets/inheritance.html.eaac8273.js"><link rel="prefetch" href="/assets/js数字精度丢失.html.da7f7af1.js"><link rel="prefetch" href="/assets/let与const.html.106c2882.js"><link rel="prefetch" href="/assets/promise.html.7d4b7269.js"><link rel="prefetch" href="/assets/type_conversion.html.d314173c.js"><link rel="prefetch" href="/assets/uniapp-websocket.html.968365cf.js"><link rel="prefetch" href="/assets/上拉加载下拉刷新.html.3a605488.js"><link rel="prefetch" href="/assets/事件循环.html.e7761663.js"><link rel="prefetch" href="/assets/作用域与作用域链.html.b32360eb.js"><link rel="prefetch" href="/assets/函数声明与函数表达式.html.39fbaa86.js"><link rel="prefetch" href="/assets/大文件断点上传.html.69e55be9.js"><link rel="prefetch" href="/assets/防抖与节流.html.a2b399eb.js"><link rel="prefetch" href="/assets/index.html.fc5b2b8d.js"><link rel="prefetch" href="/assets/maximum-split-of-positive-even-integers.html.31cd0383.js"><link rel="prefetch" href="/assets/remove-digit-from-number-to-maximize-result.html.76412a28.js"><link rel="prefetch" href="/assets/valid-palindrome.html.c4411dca.js"><link rel="prefetch" href="/assets/x的平方根.html.3a3a77a3.js"><link rel="prefetch" href="/assets/任意子数组和的绝对值的最大值.html.907a250b.js"><link rel="prefetch" href="/assets/加一.html.defed69b.js"><link rel="prefetch" href="/assets/找出字符串中第一个匹配项的下标.html.2266d611.js"><link rel="prefetch" href="/assets/搜索插入位置.html.f2da213e.js"><link rel="prefetch" href="/assets/整数的各位积和之差.html.63e7b00b.js"><link rel="prefetch" href="/assets/无重复字符的最长子串.html.4fade157.js"><link rel="prefetch" href="/assets/最后一个单词的长度.html.f91b11c8.js"><link rel="prefetch" href="/assets/有效括号.html.73235c01.js"><link rel="prefetch" href="/assets/移除元素.html.0b10e5eb.js"><link rel="prefetch" href="/assets/视频拼接.html.dfa84624.js"><link rel="prefetch" href="/assets/AST.html.42e82b2e.js"><link rel="prefetch" href="/assets/api_serve.html.722c0a5b.js"><link rel="prefetch" href="/assets/node.html.20a82773.js"><link rel="prefetch" href="/assets/restful和GraphQL.html.19b107aa.js"><link rel="prefetch" href="/assets/webpack-loader.html.f6d73145.js"><link rel="prefetch" href="/assets/webpack-plugin.html.872c9b86.js"><link rel="prefetch" href="/assets/cli命令.html.13b04263.js"><link rel="prefetch" href="/assets/session.html.fb29b683.js"><link rel="prefetch" href="/assets/创建工程.html.be2b009c.js"><link rel="prefetch" href="/assets/接口版本控制.html.a63cb3ca.js"><link rel="prefetch" href="/assets/控制器.html.1e26dc56.js"><link rel="prefetch" href="/assets/工厂方法模式.html.50b055b2.js"><link rel="prefetch" href="/assets/简单工厂模式.html.8cfa6438.js"><link rel="prefetch" href="/assets/index.html.4a732f89.js"><link rel="prefetch" href="/assets/TencentCloud.html.cc0b30c7.js"><link rel="prefetch" href="/assets/e2e.html.1b622d05.js"><link rel="prefetch" href="/assets/前端测试.html.032d9aa8.js"><link rel="prefetch" href="/assets/单元测试.html.e694d3fb.js"><link rel="prefetch" href="/assets/集成测试.html.dd1922fe.js"><link rel="prefetch" href="/assets/index.html.49d02a96.js"><link rel="prefetch" href="/assets/MVVM.html.b94f2dc7.js"><link rel="prefetch" href="/assets/index.html.0a7df9f5.js"><link rel="prefetch" href="/assets/SPA单页应用的优缺点.html.8cb480fb.js"><link rel="prefetch" href="/assets/VRouter.html.29591b15.js"><link rel="prefetch" href="/assets/Vue2数据双向绑定.html.0ade2ab1.js"><link rel="prefetch" href="/assets/Vue_cli.html.fe8c4651.js"><link rel="prefetch" href="/assets/communication.html.c7f1642f.js"><link rel="prefetch" href="/assets/proxy.html.6e32fe2c.js"><link rel="prefetch" href="/assets/vue2.html.fb324373.js"><link rel="prefetch" href="/assets/vueRouter.html.32f9a8b3.js"><link rel="prefetch" href="/assets/vuex.html.45327771.js"><link rel="prefetch" href="/assets/index.html.afd59ef3.js"><link rel="prefetch" href="/assets/axios.html.17f9b992.js"><link rel="prefetch" href="/assets/proxy.html.312e65bb.js"><link rel="prefetch" href="/assets/Props.html.0bd84170.js"><link rel="prefetch" href="/assets/Refs.html.dc733c36.js"><link rel="prefetch" href="/assets/accidence.html.cd2122f6.js"><link rel="prefetch" href="/assets/active.html.f013e811.js"><link rel="prefetch" href="/assets/component.html.4ee71c92.js"><link rel="prefetch" href="/assets/event.html.59f7fdc6.js"><link rel="prefetch" href="/assets/jsx.html.0c08a4a4.js"><link rel="prefetch" href="/assets/state.html.c905d435.js"><link rel="prefetch" href="/assets/index.html.96973c0f.js"><link rel="prefetch" href="/assets/index.html.c9390b84.js"><link rel="prefetch" href="/assets/index.html.8b2447fc.js"><link rel="prefetch" href="/assets/v5.html.1839c975.js"><link rel="prefetch" href="/assets/v6.html.541775f2.js"><link rel="prefetch" href="/assets/start.html.22055d3b.js"><link rel="prefetch" href="/assets/what.html.4625caca.js"><link rel="prefetch" href="/assets/SSRHydration.html.f9bda1d6.js"><link rel="prefetch" href="/assets/vue3NodeSSR.html.73be0959.js"><link rel="prefetch" href="/assets/vueSSRPinia.html.0f1c5956.js"><link rel="prefetch" href="/assets/vueSSRRouter.html.cd140ba1.js"><link rel="prefetch" href="/assets/api.html.328490ad.js"><link rel="prefetch" href="/assets/assest.html.9be4185a.js"><link rel="prefetch" href="/assets/components.html.728bb7bf.js"><link rel="prefetch" href="/assets/css.html.d0ff750b.js"><link rel="prefetch" href="/assets/directory.html.6354c968.js"><link rel="prefetch" href="/assets/fetch.html.b2c630bf.js"><link rel="prefetch" href="/assets/layout.html.8fdcedab.js"><link rel="prefetch" href="/assets/lifecycle.html.637c4fdc.js"><link rel="prefetch" href="/assets/nuxtConfig.html.5412f85e.js"><link rel="prefetch" href="/assets/page.html.5d9ce455.js"><link rel="prefetch" href="/assets/plugin.html.56cebf75.js"><link rel="prefetch" href="/assets/randerMode.html.24553da9.js"><link rel="prefetch" href="/assets/router.html.f1733103.js"><link rel="prefetch" href="/assets/start.html.ecc350f4.js"><link rel="prefetch" href="/assets/state.html.6e55e90b.js"><link rel="prefetch" href="/assets/ui.html.80ed50c4.js"><link rel="prefetch" href="/assets/what.html.09bfca3c.js"><link rel="prefetch" href="/assets/BOM.html.48e31bfc.js"><link rel="prefetch" href="/assets/Dom.html.b1e1ae72.js"><link rel="prefetch" href="/assets/ajax.html.6ad0a1db.js"><link rel="prefetch" href="/assets/array_api.html.6bf1f0fe.js"><link rel="prefetch" href="/assets/bind_call_apply.html.9531fde9.js"><link rel="prefetch" href="/assets/cache.html.757ab947.js"><link rel="prefetch" href="/assets/closure.html.b583d250.js"><link rel="prefetch" href="/assets/context_stack.html.166e60cc.js"><link rel="prefetch" href="/assets/continue_to_upload.html.de57643b.js"><link rel="prefetch" href="/assets/copy.html.c60d4463.js"><link rel="prefetch" href="/assets/data_type.html.0889aa15.js"><link rel="prefetch" href="/assets/debounce_throttle.html.e37c05d2.js"><link rel="prefetch" href="/assets/eq.html.470cf283.js"><link rel="prefetch" href="/assets/event_Model.html.f9013343.js"><link rel="prefetch" href="/assets/event_agent.html.840e5129.js"><link rel="prefetch" href="/assets/event_loop.html.73917c9d.js"><link rel="prefetch" href="/assets/function_cache.html.0daef069.js"><link rel="prefetch" href="/assets/functional_programming.html.373e3816.js"><link rel="prefetch" href="/assets/inherit.html.ea5ac38f.js"><link rel="prefetch" href="/assets/js_data_structure.html.c39e2d2e.js"><link rel="prefetch" href="/assets/loss_accuracy.html.eba9c878.js"><link rel="prefetch" href="/assets/memory_leak.html.3b607734.js"><link rel="prefetch" href="/assets/new.html.4e440d26.js"><link rel="prefetch" href="/assets/prototype.html.1414a639.js"><link rel="prefetch" href="/assets/pull_up_loading_pull_down_refresh.html.42cb9ef0.js"><link rel="prefetch" href="/assets/regexp.html.4f71596e.js"><link rel="prefetch" href="/assets/scope.html.2080be93.js"><link rel="prefetch" href="/assets/security.html.fa32b4f6.js"><link rel="prefetch" href="/assets/single_sign.html.9c252d8a.js"><link rel="prefetch" href="/assets/string_api.html.a422a6f7.js"><link rel="prefetch" href="/assets/tail_recursion.html.1b976097.js"><link rel="prefetch" href="/assets/this.html.9303dfa1.js"><link rel="prefetch" href="/assets/type_conversion.html.ce433e2d.js"><link rel="prefetch" href="/assets/typeof_instanceof.html.083408fe.js"><link rel="prefetch" href="/assets/visible.html.34b005b4.js"><link rel="prefetch" href="/assets/Buffer.html.6b31b62c.js"><link rel="prefetch" href="/assets/EventEmitter.html.f0717c7c.js"><link rel="prefetch" href="/assets/Stream.html.8f1b4cd5.js"><link rel="prefetch" href="/assets/event_loop.html.1b5346e3.js"><link rel="prefetch" href="/assets/file_upload.html.b7a6753b.js"><link rel="prefetch" href="/assets/fs.html.943c10af.js"><link rel="prefetch" href="/assets/global.html.aef153a6.js"><link rel="prefetch" href="/assets/jwt.html.84a99022.js"><link rel="prefetch" href="/assets/middleware.html.47733f31.js"><link rel="prefetch" href="/assets/nodejs.html.9f206107.js"><link rel="prefetch" href="/assets/paging.html.f56a9764.js"><link rel="prefetch" href="/assets/performance.html.876dbaa7.js"><link rel="prefetch" href="/assets/process.html.e3a63a9a.js"><link rel="prefetch" href="/assets/require_order.html.f9f94d05.js"><link rel="prefetch" href="/assets/Binding events.html.4fd232f5.js"><link rel="prefetch" href="/assets/Building components.html.d9128029.js"><link rel="prefetch" href="/assets/Fiber.html.42218e28.js"><link rel="prefetch" href="/assets/High order components.html.a525e53c.js"><link rel="prefetch" href="/assets/Improve performance.html.16a00916.js"><link rel="prefetch" href="/assets/JSX to DOM.html.3c10835d.js"><link rel="prefetch" href="/assets/React Hooks.html.f75f4cf1.js"><link rel="prefetch" href="/assets/React Router model.html.e94080f0.js"><link rel="prefetch" href="/assets/React Router.html.dff72a28.js"><link rel="prefetch" href="/assets/React refs.html.e160f03e.js"><link rel="prefetch" href="/assets/React.html.d6d6886c.js"><link rel="prefetch" href="/assets/Real DOM_Virtual DOM.html.9376c1a6.js"><link rel="prefetch" href="/assets/Redux Middleware.html.8fbd9c6d.js"><link rel="prefetch" href="/assets/SyntheticEvent.html.009231b7.js"><link rel="prefetch" href="/assets/animation.html.b15ffd7e.js"><link rel="prefetch" href="/assets/capture error.html.9b33b69d.js"><link rel="prefetch" href="/assets/class_function component.html.c1a8ee8f.js"><link rel="prefetch" href="/assets/communication.html.87fdafc7.js"><link rel="prefetch" href="/assets/controlled_Uncontrolled.html.c33ebdad.js"><link rel="prefetch" href="/assets/diff.html.3ab9409c.js"><link rel="prefetch" href="/assets/how to use redux.html.7dd7b46d.js"><link rel="prefetch" href="/assets/immutable.html.ec3f0ab0.js"><link rel="prefetch" href="/assets/import css.html.e0b4bf36.js"><link rel="prefetch" href="/assets/improve_render.html.905ed8d4.js"><link rel="prefetch" href="/assets/key.html.433a7a05.js"><link rel="prefetch" href="/assets/life cycle.html.bda860a8.js"><link rel="prefetch" href="/assets/redux.html.3a0767c4.js"><link rel="prefetch" href="/assets/render.html.c915c8d2.js"><link rel="prefetch" href="/assets/server side rendering.html.a4486320.js"><link rel="prefetch" href="/assets/setState.html.c72cb407.js"><link rel="prefetch" href="/assets/state_props.html.545eba58.js"><link rel="prefetch" href="/assets/summary.html.01bcdc73.js"><link rel="prefetch" href="/assets/super()_super(props).html.17fc6cdd.js"><link rel="prefetch" href="/assets/Algorithm.html.a228d9ae.js"><link rel="prefetch" href="/assets/BinarySearch.html.524f0f0a.js"><link rel="prefetch" href="/assets/Heap.html.48ab1cbf.js"><link rel="prefetch" href="/assets/Linked List.html.ae3cc3c7.js"><link rel="prefetch" href="/assets/bubbleSort.html.0081a7d0.js"><link rel="prefetch" href="/assets/design1.html.0ed48a7e.js"><link rel="prefetch" href="/assets/design2.html.16364376.js"><link rel="prefetch" href="/assets/graph.html.5796a958.js"><link rel="prefetch" href="/assets/insertionSort.html.b61fd99c.js"><link rel="prefetch" href="/assets/mergeSort.html.3fbd4157.js"><link rel="prefetch" href="/assets/quickSort.html.63b28ec1.js"><link rel="prefetch" href="/assets/selectionSort.html.0ff32cfd.js"><link rel="prefetch" href="/assets/set.html.0d39e2f1.js"><link rel="prefetch" href="/assets/sort.html.fa1cc0d1.js"><link rel="prefetch" href="/assets/stack_queue.html.47a58d63.js"><link rel="prefetch" href="/assets/structure.html.fae45705.js"><link rel="prefetch" href="/assets/time_space.html.87decc9c.js"><link rel="prefetch" href="/assets/tree.html.9ce4fb2f.js"><link rel="prefetch" href="/assets/WebView_jscore.html.c53c0f95.js"><link rel="prefetch" href="/assets/applet.html.3aa7b106.js"><link rel="prefetch" href="/assets/lifecycle.html.eeacb586.js"><link rel="prefetch" href="/assets/login.html.8aa76331.js"><link rel="prefetch" href="/assets/navigate.html.78258432.js"><link rel="prefetch" href="/assets/optimization.html.904001b7.js"><link rel="prefetch" href="/assets/publish.html.4f9da489.js"><link rel="prefetch" href="/assets/requestPayment.html.11fb9112.js"><link rel="prefetch" href="/assets/Factory  Pattern.html.9490ab5e.js"><link rel="prefetch" href="/assets/Observer  Pattern.html.07340459.js"><link rel="prefetch" href="/assets/Proxy Pattern.html.df51f315.js"><link rel="prefetch" href="/assets/Singleton Pattern.html.f925bbe6.js"><link rel="prefetch" href="/assets/Strategy Pattern.html.9fd780cc.js"><link rel="prefetch" href="/assets/design.html.17a17df3.js"><link rel="prefetch" href="/assets/BFC.html.aa483637.js"><link rel="prefetch" href="/assets/animation.html.d6548467.js"><link rel="prefetch" href="/assets/box.html.4af5ae45.js"><link rel="prefetch" href="/assets/center.html.a72f80e3.js"><link rel="prefetch" href="/assets/column_layout.html.3328a570.js"><link rel="prefetch" href="/assets/css3_features.html.b0a10093.js"><link rel="prefetch" href="/assets/css_performance.html.a53a04de.js"><link rel="prefetch" href="/assets/dp_px_dpr_ppi.html.4969d850.js"><link rel="prefetch" href="/assets/em_px_rem_vh_vw.html.94a6a4cc.js"><link rel="prefetch" href="/assets/flexbox.html.82d4a6b1.js"><link rel="prefetch" href="/assets/grid.html.d5502d04.js"><link rel="prefetch" href="/assets/hide_attributes.html.45405b08.js"><link rel="prefetch" href="/assets/layout_painting.html.be4eab3b.js"><link rel="prefetch" href="/assets/less_12px.html.cbb0080e.js"><link rel="prefetch" href="/assets/responsive_layout.html.073dc5f7.js"><link rel="prefetch" href="/assets/sass_less_stylus.html.16b03b7f.js"><link rel="prefetch" href="/assets/selector.html.d2ee4439.js"><link rel="prefetch" href="/assets/single_multi_line.html.5f9283db.js"><link rel="prefetch" href="/assets/triangle.html.65090b4a.js"><link rel="prefetch" href="/assets/visual_scrolling.html.0aa0e899.js"><link rel="prefetch" href="/assets/array.html.22c1f30b.js"><link rel="prefetch" href="/assets/decorator.html.e4ee5f5b.js"><link rel="prefetch" href="/assets/function.html.c5a37854.js"><link rel="prefetch" href="/assets/generator.html.a8a3d748.js"><link rel="prefetch" href="/assets/module.html.9bd0345b.js"><link rel="prefetch" href="/assets/object.html.eb18eba3.js"><link rel="prefetch" href="/assets/promise.html.1ea3b7cc.js"><link rel="prefetch" href="/assets/proxy.html.5eeedc87.js"><link rel="prefetch" href="/assets/set_map.html.76ad460d.js"><link rel="prefetch" href="/assets/var_let_const.html.f84daae9.js"><link rel="prefetch" href="/assets/Git.html.ec2a1af2.js"><link rel="prefetch" href="/assets/HEAD_tree_index.html.8baa16d0.js"><link rel="prefetch" href="/assets/Version control.html.1be9a919.js"><link rel="prefetch" href="/assets/command.html.f2fff969.js"><link rel="prefetch" href="/assets/conflict.html.5aca44ce.js"><link rel="prefetch" href="/assets/fork_clone_branch.html.903b5467.js"><link rel="prefetch" href="/assets/git pull _git fetch.html.d9ef127d.js"><link rel="prefetch" href="/assets/git rebase_ git merge.html.25ef3ba1.js"><link rel="prefetch" href="/assets/git reset_ git revert.html.0f7fb9eb.js"><link rel="prefetch" href="/assets/git stash.html.afa268de.js"><link rel="prefetch" href="/assets/1.0_1.1_2.0.html.2cbeff52.js"><link rel="prefetch" href="/assets/CDN.html.e34cf334.js"><link rel="prefetch" href="/assets/DNS.html.b4cae548.js"><link rel="prefetch" href="/assets/GET_POST.html.4017bfe1.js"><link rel="prefetch" href="/assets/HTTPS.html.796e4b21.js"><link rel="prefetch" href="/assets/HTTP_HTTPS.html.26e9d861.js"><link rel="prefetch" href="/assets/OSI.html.5c88af27.js"><link rel="prefetch" href="/assets/TCP_IP.html.0aeb3cb1.js"><link rel="prefetch" href="/assets/UDP_TCP.html.3916c8b6.js"><link rel="prefetch" href="/assets/WebSocket.html.9eb6cec5.js"><link rel="prefetch" href="/assets/after_url.html.284e6d69.js"><link rel="prefetch" href="/assets/handshakes_waves.html.c685f8b4.js"><link rel="prefetch" href="/assets/headers.html.0325f9b0.js"><link rel="prefetch" href="/assets/status.html.e8d69086.js"><link rel="prefetch" href="/assets/file.html.aa695a90.js"><link rel="prefetch" href="/assets/linux users.html.440e6ef4.js"><link rel="prefetch" href="/assets/linux.html.d8536ab3.js"><link rel="prefetch" href="/assets/redirect_pipe.html.08bb81a5.js"><link rel="prefetch" href="/assets/shell.html.4d665fe7.js"><link rel="prefetch" href="/assets/thread_process.html.63537673.js"><link rel="prefetch" href="/assets/vim.html.43d58886.js"><link rel="prefetch" href="/assets/class.html.3befb588.js"><link rel="prefetch" href="/assets/data_type.html.76cd97fd.js"><link rel="prefetch" href="/assets/decorator.html.a7a7935d.js"><link rel="prefetch" href="/assets/enum.html.859df879.js"><link rel="prefetch" href="/assets/function.html.259e4d2b.js"><link rel="prefetch" href="/assets/generic.html.3ae9ed05.js"><link rel="prefetch" href="/assets/high type.html.6b9ec615.js"><link rel="prefetch" href="/assets/interface.html.3b584ecb.js"><link rel="prefetch" href="/assets/namespace_module.html.dd7e0e6a.js"><link rel="prefetch" href="/assets/react.html.fef00283.js"><link rel="prefetch" href="/assets/typescript_javascript.html.9fac618b.js"><link rel="prefetch" href="/assets/vue.html.9a392adc.js"><link rel="prefetch" href="/assets/404.html.029feb6f.js"><link rel="prefetch" href="/assets/axios.html.b9c2362e.js"><link rel="prefetch" href="/assets/axiosCode.html.569c2fd8.js"><link rel="prefetch" href="/assets/bind.html.a97fc330.js"><link rel="prefetch" href="/assets/communication.html.1bfc4e55.js"><link rel="prefetch" href="/assets/components_plugin.html.a47c8283.js"><link rel="prefetch" href="/assets/cors.html.fe836c3a.js"><link rel="prefetch" href="/assets/data.html.1a04b964.js"><link rel="prefetch" href="/assets/data_object_add_attrs.html.bafadf10.js"><link rel="prefetch" href="/assets/diff.html.51c964b2.js"><link rel="prefetch" href="/assets/directive.html.9d6b9fa4.js"><link rel="prefetch" href="/assets/error.html.e10e7025.js"><link rel="prefetch" href="/assets/filter.html.85f9f66f.js"><link rel="prefetch" href="/assets/first_page_time.html.7da8e638.js"><link rel="prefetch" href="/assets/if_for.html.5124d3c6.js"><link rel="prefetch" href="/assets/keepalive.html.fa0519af.js"><link rel="prefetch" href="/assets/key.html.c62d4fd2.js"><link rel="prefetch" href="/assets/lifecycle.html.1449df5a.js"><link rel="prefetch" href="/assets/mixin.html.0ead5c5b.js"><link rel="prefetch" href="/assets/modifier.html.b57ac2bc.js"><link rel="prefetch" href="/assets/new_vue.html.ce7a843f.js"><link rel="prefetch" href="/assets/nexttick.html.7f4e3741.js"><link rel="prefetch" href="/assets/observable.html.6840d15b.js"><link rel="prefetch" href="/assets/permission.html.d44ac209.js"><link rel="prefetch" href="/assets/show_if.html.6b96524c.js"><link rel="prefetch" href="/assets/slot.html.81c49f5f.js"><link rel="prefetch" href="/assets/spa.html.10bed72d.js"><link rel="prefetch" href="/assets/ssr.html.fdbf4f62.js"><link rel="prefetch" href="/assets/structure.html.412e4eab.js"><link rel="prefetch" href="/assets/vnode.html.92b981a6.js"><link rel="prefetch" href="/assets/vue.html.04888652.js"><link rel="prefetch" href="/assets/vue3_vue2.html.20c4167f.js"><link rel="prefetch" href="/assets/composition.html.09a9fc89.js"><link rel="prefetch" href="/assets/goal.html.3607b58e.js"><link rel="prefetch" href="/assets/modal_component.html.213bc6b9.js"><link rel="prefetch" href="/assets/performance.html.4bb77ebd.js"><link rel="prefetch" href="/assets/proxy.html.ee7fab38.js"><link rel="prefetch" href="/assets/treeshaking.html.4f9b7253.js"><link rel="prefetch" href="/assets/HMR.html.75624c66.js"><link rel="prefetch" href="/assets/Loader.html.57fb5f3d.js"><link rel="prefetch" href="/assets/Loader_Plugin.html.824b6c7c.js"><link rel="prefetch" href="/assets/Plugin.html.47660c54.js"><link rel="prefetch" href="/assets/Rollup_Parcel_snowpack_Vite.html.ee0bee61.js"><link rel="prefetch" href="/assets/build_process.html.6f051e53.js"><link rel="prefetch" href="/assets/improve_build.html.7e8b58f6.js"><link rel="prefetch" href="/assets/performance.html.85de32f9.js"><link rel="prefetch" href="/assets/proxy.html.90e4bb39.js"><link rel="prefetch" href="/assets/webpack.html.dce4d29b.js"><link rel="prefetch" href="/assets/中间件.html.a8e43b71.js"><link rel="prefetch" href="/assets/启动一个koa服务.html.aa9ca870.js"><link rel="prefetch" href="/assets/日志中间件.html.ccf42f1a.js"><link rel="prefetch" href="/assets/index.html.a8e2f293.js"><link rel="prefetch" href="/assets/index.html.535ae59c.js"><link rel="prefetch" href="/assets/index.html.ca1029bf.js"><link rel="prefetch" href="/assets/dict.html.f48a4b61.js"><link rel="prefetch" href="/assets/file.html.a6bba23e.js"><link rel="prefetch" href="/assets/func.html.13aa42f8.js"><link rel="prefetch" href="/assets/list.html.406dd2ae.js"><link rel="prefetch" href="/assets/module.html.87417e1f.js"><link rel="prefetch" href="/assets/set.html.4071a3b6.js"><link rel="prefetch" href="/assets/slice.html.431af614.js"><link rel="prefetch" href="/assets/str.html.58041037.js"><link rel="prefetch" href="/assets/tuple.html.5ee49fa9.js"><link rel="prefetch" href="/assets/index.html.ec3c8992.js"><link rel="prefetch" href="/assets/index.html.bc905718.js"><link rel="prefetch" href="/assets/index.html.d3a5ceeb.js"><link rel="prefetch" href="/assets/index.html.64454dbb.js"><link rel="prefetch" href="/assets/index.html.6c539749.js"><link rel="prefetch" href="/assets/index.html.b236878d.js"><link rel="prefetch" href="/assets/index.html.1099776e.js"><link rel="prefetch" href="/assets/index.html.fdd5e55e.js"><link rel="prefetch" href="/assets/index.html.0aaa4a8a.js"><link rel="prefetch" href="/assets/index.html.b4aae169.js"><link rel="prefetch" href="/assets/analyze.html.47ec30fb.js"><link rel="prefetch" href="/assets/composition.html.3ff7184d.js"><link rel="prefetch" href="/assets/create.html.8394bc24.js"><link rel="prefetch" href="/assets/vue-3.3.html.3c64ed95.js"><link rel="prefetch" href="/assets/index.html.a26cf992.js"><link rel="prefetch" href="/assets/index.html.1c28838b.js"><link rel="prefetch" href="/assets/index.html.69f69ed3.js"><link rel="prefetch" href="/assets/base.html.8bb66ec3.js"><link rel="prefetch" href="/assets/clean.html.60506f4b.js"><link rel="prefetch" href="/assets/config.html.eb8fd16c.js"><link rel="prefetch" href="/assets/css.html.449bbe0b.js"><link rel="prefetch" href="/assets/development.html.9690762f.js"><link rel="prefetch" href="/assets/font.html.18e0a57d.js"><link rel="prefetch" href="/assets/html.html.f06d65d4.js"><link rel="prefetch" href="/assets/image.html.29f050d3.js"><link rel="prefetch" href="/assets/javascript.html.2a5723ab.js"><link rel="prefetch" href="/assets/optimizeCss.html.9b5eb301.js"><link rel="prefetch" href="/assets/output.html.85edf2a9.js"><link rel="prefetch" href="/assets/production.html.fbcc3835.js"><link rel="prefetch" href="/assets/serve.html.ff06dea4.js"><link rel="prefetch" href="/assets/index.html.14eac029.js"><link rel="prefetch" href="/assets/vue-cli.html.2c1de22b.js"><link rel="prefetch" href="/assets/index.html.26e8a5a9.js"><link rel="prefetch" href="/assets/enhanceExperience.html.6f5cd0f3.js"><link rel="prefetch" href="/assets/liftingSpeed.html.957466da.js"><link rel="prefetch" href="/assets/optimizePerformance.html.1dd0e990.js"><link rel="prefetch" href="/assets/reduceVolume.html.16bc7d4f.js"><link rel="prefetch" href="/assets/summary.html.9226349b.js"><link rel="prefetch" href="/assets/404.html.c3e557d0.js"><link rel="prefetch" href="/assets/index.html.06100e77.js"><link rel="prefetch" href="/assets/git.html.ea3660ad.js"><link rel="prefetch" href="/assets/github.html.a79d7b05.js"><link rel="prefetch" href="/assets/CSS引入方式.html.932f57a9.js"><link rel="prefetch" href="/assets/CSS架构模式之BEM.html.414412ce.js"><link rel="prefetch" href="/assets/CSS样式优先级.html.e01878dc.js"><link rel="prefetch" href="/assets/CSS盒子模型.html.33a0ffc4.js"><link rel="prefetch" href="/assets/CSS选择器.html.95e44384.js"><link rel="prefetch" href="/assets/CSS隐藏元素的方法.html.783ff396.js"><link rel="prefetch" href="/assets/Flex布局.html.5c9e773b.js"><link rel="prefetch" href="/assets/Float浮动.html.3d85c6cf.js"><link rel="prefetch" href="/assets/Grid布局.html.91fbd122.js"><link rel="prefetch" href="/assets/Position定位.html.753e8802.js"><link rel="prefetch" href="/assets/index.html.f6af0325.js"><link rel="prefetch" href="/assets/css.html.d8fefc2e.js"><link rel="prefetch" href="/assets/css3新特性.html.38fd285c.js"><link rel="prefetch" href="/assets/实现三栏布局.html.1f6f830e.js"><link rel="prefetch" href="/assets/布局垂直居中.html.9754a318.js"><link rel="prefetch" href="/assets/index.html.22627c76.js"><link rel="prefetch" href="/assets/Cookie与Session.html.4ae5f4b4.js"><link rel="prefetch" href="/assets/DOM和BOM的区别.html.8f9b3afd.js"><link rel="prefetch" href="/assets/HTML5新特性.html.df7e10a6.js"><link rel="prefetch" href="/assets/HTML语义化.html.4ff25fa5.js"><link rel="prefetch" href="/assets/LocalStorage与SessionStorage.html.223d3237.js"><link rel="prefetch" href="/assets/doctype.html.f5a49577.js"><link rel="prefetch" href="/assets/前端性能优化方案.html.e3c58909.js"><link rel="prefetch" href="/assets/行内元素和块级元素.html.1365317b.js"><link rel="prefetch" href="/assets/index.html.91204217.js"><link rel="prefetch" href="/assets/index.html.8cc28069.js"><link rel="prefetch" href="/assets/GPIO.html.7660e282.js"><link rel="prefetch" href="/assets/index.html.c9a95c71.js"><link rel="prefetch" href="/assets/Serial.html.ba9a88a0.js"><link rel="prefetch" href="/assets/clock.html.e161e76c.js"><link rel="prefetch" href="/assets/index.html.73483f68.js"><link rel="prefetch" href="/assets/base.html.d61392cc.js"><link rel="prefetch" href="/assets/config.html.a2ad9e31.js"><link rel="prefetch" href="/assets/high_type.html.a6259660.js"><link rel="prefetch" href="/assets/type.html.89f24296.js"><link rel="prefetch" href="/assets/typeFile.html.3145d773.js"><link rel="prefetch" href="/assets/index.html.895bf01b.js"><link rel="prefetch" href="/assets/linux_command.html.a1223ba1.js"><link rel="prefetch" href="/assets/option.html.17eae772.js"><link rel="prefetch" href="/assets/初始化组件库.html.dde75287.js"><link rel="prefetch" href="/assets/组件库工程化.html.fe7fabf7.js"><link rel="prefetch" href="/assets/Array.html.165eadad.js"><link rel="prefetch" href="/assets/Destructuring.html.6b1a4f7c.js"><link rel="prefetch" href="/assets/Object.html.e774b1c9.js"><link rel="prefetch" href="/assets/Promise.html.68b29eb9.js"><link rel="prefetch" href="/assets/Prototype.html.7fa28e9e.js"><link rel="prefetch" href="/assets/guide1.html.f3f9733c.js"><link rel="prefetch" href="/assets/index.html.32c73389.js"><link rel="prefetch" href="/assets/BOM对象.html.ad7fd208.js"><link rel="prefetch" href="/assets/cookie.html.89fd9c26.js"><link rel="prefetch" href="/assets/webWorker.html.9deca020.js"><link rel="prefetch" href="/assets/apply-call-bind.html.422e7433.js"><link rel="prefetch" href="/assets/object属性.html.8fb158d0.js"><link rel="prefetch" href="/assets/promise.html.14f18ba3.js"><link rel="prefetch" href="/assets/sort.html.a734b667.js"><link rel="prefetch" href="/assets/对象按要求填充数组.html.5b29c444.js"><link rel="prefetch" href="/assets/排序算法.html.ecf41f7f.js"><link rel="prefetch" href="/assets/获取出现次数前三的tag.html.ea496fa5.js"><link rel="prefetch" href="/assets/连续赋值.html.d93595a2.js"><link rel="prefetch" href="/assets/动画.html.0e6621c7.js"><link rel="prefetch" href="/assets/重绘和重排.html.841f9e03.js"><link rel="prefetch" href="/assets/2023-07-12.html.ad064cad.js"><link rel="prefetch" href="/assets/2023-07-19.html.269249ea.js"><link rel="prefetch" href="/assets/2023-07-20.html.bccee5c9.js"><link rel="prefetch" href="/assets/2023-07-25-fd.html.00299722.js"><link rel="prefetch" href="/assets/2023-07-25.html.3aa53452.js"><link rel="prefetch" href="/assets/showmebug.html.e7d1b76e.js"><link rel="prefetch" href="/assets/常见面试题.html.bab7f10e.js"><link rel="prefetch" href="/assets/npmInstall.html.98221f7e.js"><link rel="prefetch" href="/assets/npm和yarn和pnpm对比.html.38891408.js"><link rel="prefetch" href="/assets/ref-toRef-toRefs.html.ae93870c.js"><link rel="prefetch" href="/assets/ref和reactive区别.html.5e4e65b2.js"><link rel="prefetch" href="/assets/JS遍历对象.html.07a94733.js"><link rel="prefetch" href="/assets/JS遍历数组.html.a1e7e28a.js"><link rel="prefetch" href="/assets/addEventListener.html.b800d8ec.js"><link rel="prefetch" href="/assets/ajax.html.99b0fc81.js"><link rel="prefetch" href="/assets/webworker.html.c4e803f2.js"><link rel="prefetch" href="/assets/严格模式.html.12a69611.js"><link rel="prefetch" href="/assets/函数式编程.html.3240f7bf.js"><link rel="prefetch" href="/assets/判断数组的方法.html.58351930.js"><link rel="prefetch" href="/assets/箭头函数和普通函数的区别.html.ad350d32.js"><link rel="prefetch" href="/assets/TCP-IP协议.html.37ac4006.js"><link rel="prefetch" href="/assets/TCP三次握手四次挥手.html.5badbde2.js"><link rel="prefetch" href="/assets/http状态码.html.a7d44ce3.js"><link rel="prefetch" href="/assets/node_tcp.html.5cde5a30.js"><link rel="prefetch" href="/assets/node_udp.html.f988ea45.js"><link rel="prefetch" href="/assets/网络请求.html.2221758f.js"><link rel="prefetch" href="/assets/ES6新特性.html.cec2054c.js"><link rel="prefetch" href="/assets/JS变量提升.html.90339c09.js"><link rel="prefetch" href="/assets/Js模块化导入导出.html.542ef04f.js"><link rel="prefetch" href="/assets/Js箭头函数.html.5d8e50e1.js"><link rel="prefetch" href="/assets/index.html.f151da15.js"><link rel="prefetch" href="/assets/Symbol.html.d4218880.js"><link rel="prefetch" href="/assets/array.html.b518a15b.js"><link rel="prefetch" href="/assets/copy.html.37430115.js"><link rel="prefetch" href="/assets/data_type.html.51f3f360.js"><link rel="prefetch" href="/assets/defineProperty.html.de9dee5c.js"><link rel="prefetch" href="/assets/eq.html.aa276a99.js"><link rel="prefetch" href="/assets/inheritance.html.f4ef3d5e.js"><link rel="prefetch" href="/assets/js数字精度丢失.html.29a3ce5c.js"><link rel="prefetch" href="/assets/let与const.html.6bc7f6f5.js"><link rel="prefetch" href="/assets/promise.html.4c9c4a9e.js"><link rel="prefetch" href="/assets/type_conversion.html.84c25b36.js"><link rel="prefetch" href="/assets/uniapp-websocket.html.a543ff2b.js"><link rel="prefetch" href="/assets/上拉加载下拉刷新.html.9c5b1446.js"><link rel="prefetch" href="/assets/事件循环.html.9531ca50.js"><link rel="prefetch" href="/assets/作用域与作用域链.html.ddff487c.js"><link rel="prefetch" href="/assets/函数声明与函数表达式.html.2aa71b24.js"><link rel="prefetch" href="/assets/大文件断点上传.html.5207426b.js"><link rel="prefetch" href="/assets/防抖与节流.html.f3c9a160.js"><link rel="prefetch" href="/assets/index.html.575ac80e.js"><link rel="prefetch" href="/assets/maximum-split-of-positive-even-integers.html.5190e7c8.js"><link rel="prefetch" href="/assets/remove-digit-from-number-to-maximize-result.html.6acc3ed0.js"><link rel="prefetch" href="/assets/valid-palindrome.html.9e328920.js"><link rel="prefetch" href="/assets/x的平方根.html.dff26a4d.js"><link rel="prefetch" href="/assets/任意子数组和的绝对值的最大值.html.a2b71362.js"><link rel="prefetch" href="/assets/加一.html.2a9cfb9f.js"><link rel="prefetch" href="/assets/找出字符串中第一个匹配项的下标.html.91e52d84.js"><link rel="prefetch" href="/assets/搜索插入位置.html.c5a544ec.js"><link rel="prefetch" href="/assets/整数的各位积和之差.html.155698d3.js"><link rel="prefetch" href="/assets/无重复字符的最长子串.html.8bd3e796.js"><link rel="prefetch" href="/assets/最后一个单词的长度.html.bae7d132.js"><link rel="prefetch" href="/assets/有效括号.html.addcf4d3.js"><link rel="prefetch" href="/assets/移除元素.html.3fe93d26.js"><link rel="prefetch" href="/assets/视频拼接.html.18a84fc5.js"><link rel="prefetch" href="/assets/AST.html.981fb9ab.js"><link rel="prefetch" href="/assets/api_serve.html.29796f90.js"><link rel="prefetch" href="/assets/node.html.b506a7e7.js"><link rel="prefetch" href="/assets/restful和GraphQL.html.d1055a84.js"><link rel="prefetch" href="/assets/webpack-loader.html.a6585b6d.js"><link rel="prefetch" href="/assets/webpack-plugin.html.10bfb5f5.js"><link rel="prefetch" href="/assets/cli命令.html.3bb2fe8c.js"><link rel="prefetch" href="/assets/session.html.70d3e42a.js"><link rel="prefetch" href="/assets/创建工程.html.7f7be79f.js"><link rel="prefetch" href="/assets/接口版本控制.html.0bf6f00a.js"><link rel="prefetch" href="/assets/控制器.html.e9bd9549.js"><link rel="prefetch" href="/assets/工厂方法模式.html.7af1f1e1.js"><link rel="prefetch" href="/assets/简单工厂模式.html.1c0a2c51.js"><link rel="prefetch" href="/assets/index.html.c376553c.js"><link rel="prefetch" href="/assets/TencentCloud.html.147f7032.js"><link rel="prefetch" href="/assets/e2e.html.ae80f18a.js"><link rel="prefetch" href="/assets/前端测试.html.7cf00a0f.js"><link rel="prefetch" href="/assets/单元测试.html.6cc66910.js"><link rel="prefetch" href="/assets/集成测试.html.cf3daa16.js"><link rel="prefetch" href="/assets/index.html.5f74e98e.js"><link rel="prefetch" href="/assets/MVVM.html.52cd8fca.js"><link rel="prefetch" href="/assets/index.html.1a90d431.js"><link rel="prefetch" href="/assets/SPA单页应用的优缺点.html.a4b78c12.js"><link rel="prefetch" href="/assets/VRouter.html.aeddaac2.js"><link rel="prefetch" href="/assets/Vue2数据双向绑定.html.bad93f05.js"><link rel="prefetch" href="/assets/Vue_cli.html.3d292c25.js"><link rel="prefetch" href="/assets/communication.html.04c7fc73.js"><link rel="prefetch" href="/assets/proxy.html.77ccc9ae.js"><link rel="prefetch" href="/assets/vue2.html.8113f469.js"><link rel="prefetch" href="/assets/vueRouter.html.85a8401e.js"><link rel="prefetch" href="/assets/vuex.html.c8cbbb74.js"><link rel="prefetch" href="/assets/index.html.18942d76.js"><link rel="prefetch" href="/assets/axios.html.fc389e68.js"><link rel="prefetch" href="/assets/proxy.html.7a2c6e90.js"><link rel="prefetch" href="/assets/Props.html.531b6d9a.js"><link rel="prefetch" href="/assets/Refs.html.910c1e89.js"><link rel="prefetch" href="/assets/accidence.html.7e28df09.js"><link rel="prefetch" href="/assets/active.html.e23243fc.js"><link rel="prefetch" href="/assets/component.html.e69b8741.js"><link rel="prefetch" href="/assets/event.html.ac0899e5.js"><link rel="prefetch" href="/assets/jsx.html.e3013120.js"><link rel="prefetch" href="/assets/state.html.4d7702f1.js"><link rel="prefetch" href="/assets/index.html.d0d94020.js"><link rel="prefetch" href="/assets/index.html.9baf9411.js"><link rel="prefetch" href="/assets/index.html.52eea262.js"><link rel="prefetch" href="/assets/v5.html.949c0eef.js"><link rel="prefetch" href="/assets/v6.html.26fd0f23.js"><link rel="prefetch" href="/assets/start.html.eb189248.js"><link rel="prefetch" href="/assets/what.html.b48861a1.js"><link rel="prefetch" href="/assets/SSRHydration.html.5dd3740f.js"><link rel="prefetch" href="/assets/vue3NodeSSR.html.90375d05.js"><link rel="prefetch" href="/assets/vueSSRPinia.html.00efc7ed.js"><link rel="prefetch" href="/assets/vueSSRRouter.html.6550322c.js"><link rel="prefetch" href="/assets/api.html.c4ca9a35.js"><link rel="prefetch" href="/assets/assest.html.d90ecf99.js"><link rel="prefetch" href="/assets/components.html.412632c7.js"><link rel="prefetch" href="/assets/css.html.28e969d3.js"><link rel="prefetch" href="/assets/directory.html.dbe89878.js"><link rel="prefetch" href="/assets/fetch.html.82e50dfc.js"><link rel="prefetch" href="/assets/layout.html.20429cd1.js"><link rel="prefetch" href="/assets/lifecycle.html.2892362e.js"><link rel="prefetch" href="/assets/nuxtConfig.html.0ab9c129.js"><link rel="prefetch" href="/assets/page.html.0eb12979.js"><link rel="prefetch" href="/assets/plugin.html.cfaa8fb0.js"><link rel="prefetch" href="/assets/randerMode.html.121ebbfc.js"><link rel="prefetch" href="/assets/router.html.7ca6ced0.js"><link rel="prefetch" href="/assets/start.html.94bbdaae.js"><link rel="prefetch" href="/assets/state.html.43934d4c.js"><link rel="prefetch" href="/assets/ui.html.5fae6408.js"><link rel="prefetch" href="/assets/what.html.1d192fd0.js"><link rel="prefetch" href="/assets/BOM.html.648ee5fa.js"><link rel="prefetch" href="/assets/Dom.html.6bef5697.js"><link rel="prefetch" href="/assets/ajax.html.e8d05b87.js"><link rel="prefetch" href="/assets/array_api.html.35c52527.js"><link rel="prefetch" href="/assets/bind_call_apply.html.d3b11247.js"><link rel="prefetch" href="/assets/cache.html.610f6384.js"><link rel="prefetch" href="/assets/closure.html.8f38f9f1.js"><link rel="prefetch" href="/assets/context_stack.html.ee689862.js"><link rel="prefetch" href="/assets/continue_to_upload.html.12efde36.js"><link rel="prefetch" href="/assets/copy.html.d2dbde0e.js"><link rel="prefetch" href="/assets/data_type.html.f24b637a.js"><link rel="prefetch" href="/assets/debounce_throttle.html.48323574.js"><link rel="prefetch" href="/assets/eq.html.3d67a03e.js"><link rel="prefetch" href="/assets/event_Model.html.5938bec7.js"><link rel="prefetch" href="/assets/event_agent.html.13b11abb.js"><link rel="prefetch" href="/assets/event_loop.html.040e2512.js"><link rel="prefetch" href="/assets/function_cache.html.3403599b.js"><link rel="prefetch" href="/assets/functional_programming.html.5eae5778.js"><link rel="prefetch" href="/assets/inherit.html.12503399.js"><link rel="prefetch" href="/assets/js_data_structure.html.83f3f2ef.js"><link rel="prefetch" href="/assets/loss_accuracy.html.437d4d24.js"><link rel="prefetch" href="/assets/memory_leak.html.1d2122b0.js"><link rel="prefetch" href="/assets/new.html.97eaa7a0.js"><link rel="prefetch" href="/assets/prototype.html.bdde10dd.js"><link rel="prefetch" href="/assets/pull_up_loading_pull_down_refresh.html.283da9d2.js"><link rel="prefetch" href="/assets/regexp.html.6f6e0225.js"><link rel="prefetch" href="/assets/scope.html.3a714b6f.js"><link rel="prefetch" href="/assets/security.html.f5d2ecce.js"><link rel="prefetch" href="/assets/single_sign.html.62110db2.js"><link rel="prefetch" href="/assets/string_api.html.f63496c2.js"><link rel="prefetch" href="/assets/tail_recursion.html.27a2e935.js"><link rel="prefetch" href="/assets/this.html.42263c1e.js"><link rel="prefetch" href="/assets/type_conversion.html.8c27184d.js"><link rel="prefetch" href="/assets/typeof_instanceof.html.24ca9243.js"><link rel="prefetch" href="/assets/visible.html.e124fb89.js"><link rel="prefetch" href="/assets/Buffer.html.d0447a9c.js"><link rel="prefetch" href="/assets/EventEmitter.html.67d27ca4.js"><link rel="prefetch" href="/assets/Stream.html.897b3f18.js"><link rel="prefetch" href="/assets/event_loop.html.0bf69fc9.js"><link rel="prefetch" href="/assets/file_upload.html.d8815d1d.js"><link rel="prefetch" href="/assets/fs.html.e7d3908a.js"><link rel="prefetch" href="/assets/global.html.735559f5.js"><link rel="prefetch" href="/assets/jwt.html.96893317.js"><link rel="prefetch" href="/assets/middleware.html.13521a3c.js"><link rel="prefetch" href="/assets/nodejs.html.58347796.js"><link rel="prefetch" href="/assets/paging.html.5b7d8b60.js"><link rel="prefetch" href="/assets/performance.html.085aa70e.js"><link rel="prefetch" href="/assets/process.html.9d208ddb.js"><link rel="prefetch" href="/assets/require_order.html.1de74712.js"><link rel="prefetch" href="/assets/Binding events.html.6d70b013.js"><link rel="prefetch" href="/assets/Building components.html.d2da1118.js"><link rel="prefetch" href="/assets/Fiber.html.ffeba14d.js"><link rel="prefetch" href="/assets/High order components.html.1e28a1bb.js"><link rel="prefetch" href="/assets/Improve performance.html.ec0aa1c5.js"><link rel="prefetch" href="/assets/JSX to DOM.html.4652e222.js"><link rel="prefetch" href="/assets/React Hooks.html.b1ff85dc.js"><link rel="prefetch" href="/assets/React Router model.html.c6a31f88.js"><link rel="prefetch" href="/assets/React Router.html.fb6fb706.js"><link rel="prefetch" href="/assets/React refs.html.8bf3bbfe.js"><link rel="prefetch" href="/assets/React.html.f930d3b8.js"><link rel="prefetch" href="/assets/Real DOM_Virtual DOM.html.33251a34.js"><link rel="prefetch" href="/assets/Redux Middleware.html.2dcbdc6e.js"><link rel="prefetch" href="/assets/SyntheticEvent.html.df77897d.js"><link rel="prefetch" href="/assets/animation.html.a2c2cd55.js"><link rel="prefetch" href="/assets/capture error.html.203e9c9e.js"><link rel="prefetch" href="/assets/class_function component.html.977ecbf2.js"><link rel="prefetch" href="/assets/communication.html.261a74b3.js"><link rel="prefetch" href="/assets/controlled_Uncontrolled.html.39deaedc.js"><link rel="prefetch" href="/assets/diff.html.e7e06c12.js"><link rel="prefetch" href="/assets/how to use redux.html.d4bbba2e.js"><link rel="prefetch" href="/assets/immutable.html.e94d0165.js"><link rel="prefetch" href="/assets/import css.html.b8b4df7a.js"><link rel="prefetch" href="/assets/improve_render.html.c9ac9755.js"><link rel="prefetch" href="/assets/key.html.0ca4f023.js"><link rel="prefetch" href="/assets/life cycle.html.925fffdb.js"><link rel="prefetch" href="/assets/redux.html.40b8adc7.js"><link rel="prefetch" href="/assets/render.html.84d29089.js"><link rel="prefetch" href="/assets/server side rendering.html.ec98d6f7.js"><link rel="prefetch" href="/assets/setState.html.aaeea031.js"><link rel="prefetch" href="/assets/state_props.html.89f3700c.js"><link rel="prefetch" href="/assets/summary.html.eb9a0e3f.js"><link rel="prefetch" href="/assets/super()_super(props).html.ccd67462.js"><link rel="prefetch" href="/assets/Algorithm.html.659cb7ca.js"><link rel="prefetch" href="/assets/BinarySearch.html.2c7f0844.js"><link rel="prefetch" href="/assets/Heap.html.d9851afb.js"><link rel="prefetch" href="/assets/Linked List.html.ded9e72d.js"><link rel="prefetch" href="/assets/bubbleSort.html.560cd820.js"><link rel="prefetch" href="/assets/design1.html.34eeed11.js"><link rel="prefetch" href="/assets/design2.html.16a8c2f4.js"><link rel="prefetch" href="/assets/graph.html.60245f98.js"><link rel="prefetch" href="/assets/insertionSort.html.8be3b63d.js"><link rel="prefetch" href="/assets/mergeSort.html.99061a67.js"><link rel="prefetch" href="/assets/quickSort.html.9d584d73.js"><link rel="prefetch" href="/assets/selectionSort.html.f0abdacb.js"><link rel="prefetch" href="/assets/set.html.f5efb91f.js"><link rel="prefetch" href="/assets/sort.html.d3a98824.js"><link rel="prefetch" href="/assets/stack_queue.html.8f8cf32a.js"><link rel="prefetch" href="/assets/structure.html.7f5db46a.js"><link rel="prefetch" href="/assets/time_space.html.216a05b3.js"><link rel="prefetch" href="/assets/tree.html.ce22c932.js"><link rel="prefetch" href="/assets/WebView_jscore.html.8710d89a.js"><link rel="prefetch" href="/assets/applet.html.cd899fe8.js"><link rel="prefetch" href="/assets/lifecycle.html.f2d4e6f8.js"><link rel="prefetch" href="/assets/login.html.77d73c26.js"><link rel="prefetch" href="/assets/navigate.html.d37c92db.js"><link rel="prefetch" href="/assets/optimization.html.b04b325b.js"><link rel="prefetch" href="/assets/publish.html.16024030.js"><link rel="prefetch" href="/assets/requestPayment.html.e327bce4.js"><link rel="prefetch" href="/assets/Factory  Pattern.html.009ac382.js"><link rel="prefetch" href="/assets/Observer  Pattern.html.c97bbd61.js"><link rel="prefetch" href="/assets/Proxy Pattern.html.f73ef165.js"><link rel="prefetch" href="/assets/Singleton Pattern.html.670cf61f.js"><link rel="prefetch" href="/assets/Strategy Pattern.html.0533be40.js"><link rel="prefetch" href="/assets/design.html.71d178c2.js"><link rel="prefetch" href="/assets/BFC.html.8da444c1.js"><link rel="prefetch" href="/assets/animation.html.81fc9e0f.js"><link rel="prefetch" href="/assets/box.html.7ccd09ff.js"><link rel="prefetch" href="/assets/center.html.aa5aafa4.js"><link rel="prefetch" href="/assets/column_layout.html.75dd6a9f.js"><link rel="prefetch" href="/assets/css3_features.html.0a0eaa1f.js"><link rel="prefetch" href="/assets/css_performance.html.616ad631.js"><link rel="prefetch" href="/assets/dp_px_dpr_ppi.html.1ea1b252.js"><link rel="prefetch" href="/assets/em_px_rem_vh_vw.html.e673d355.js"><link rel="prefetch" href="/assets/flexbox.html.f20a1b8d.js"><link rel="prefetch" href="/assets/grid.html.c3dc4f8d.js"><link rel="prefetch" href="/assets/hide_attributes.html.df606eed.js"><link rel="prefetch" href="/assets/layout_painting.html.630dd815.js"><link rel="prefetch" href="/assets/less_12px.html.b9344a19.js"><link rel="prefetch" href="/assets/responsive_layout.html.c988c4f6.js"><link rel="prefetch" href="/assets/sass_less_stylus.html.885ecc9f.js"><link rel="prefetch" href="/assets/selector.html.d2c2bd01.js"><link rel="prefetch" href="/assets/single_multi_line.html.ac603e23.js"><link rel="prefetch" href="/assets/triangle.html.02c8c4b5.js"><link rel="prefetch" href="/assets/visual_scrolling.html.e1512c81.js"><link rel="prefetch" href="/assets/array.html.ca0cd265.js"><link rel="prefetch" href="/assets/decorator.html.b9ccf59c.js"><link rel="prefetch" href="/assets/function.html.57d2614b.js"><link rel="prefetch" href="/assets/generator.html.f3f100d9.js"><link rel="prefetch" href="/assets/module.html.40b4c997.js"><link rel="prefetch" href="/assets/object.html.84177985.js"><link rel="prefetch" href="/assets/promise.html.598eefa4.js"><link rel="prefetch" href="/assets/proxy.html.c96df110.js"><link rel="prefetch" href="/assets/set_map.html.366594c9.js"><link rel="prefetch" href="/assets/var_let_const.html.04599450.js"><link rel="prefetch" href="/assets/Git.html.c8a9b9e1.js"><link rel="prefetch" href="/assets/HEAD_tree_index.html.19d74a3e.js"><link rel="prefetch" href="/assets/Version control.html.0a7f0f54.js"><link rel="prefetch" href="/assets/command.html.ceac8e9e.js"><link rel="prefetch" href="/assets/conflict.html.78fb04be.js"><link rel="prefetch" href="/assets/fork_clone_branch.html.4b120917.js"><link rel="prefetch" href="/assets/git pull _git fetch.html.1fee926b.js"><link rel="prefetch" href="/assets/git rebase_ git merge.html.bba0d573.js"><link rel="prefetch" href="/assets/git reset_ git revert.html.f3248575.js"><link rel="prefetch" href="/assets/git stash.html.e9010dc7.js"><link rel="prefetch" href="/assets/1.0_1.1_2.0.html.3507e0ef.js"><link rel="prefetch" href="/assets/CDN.html.81cf8408.js"><link rel="prefetch" href="/assets/DNS.html.74c16774.js"><link rel="prefetch" href="/assets/GET_POST.html.074f5197.js"><link rel="prefetch" href="/assets/HTTPS.html.b6623d7d.js"><link rel="prefetch" href="/assets/HTTP_HTTPS.html.37ce3744.js"><link rel="prefetch" href="/assets/OSI.html.568213f2.js"><link rel="prefetch" href="/assets/TCP_IP.html.58d2e84f.js"><link rel="prefetch" href="/assets/UDP_TCP.html.d649abd5.js"><link rel="prefetch" href="/assets/WebSocket.html.380fa9c9.js"><link rel="prefetch" href="/assets/after_url.html.e05d2723.js"><link rel="prefetch" href="/assets/handshakes_waves.html.1a796fc7.js"><link rel="prefetch" href="/assets/headers.html.c7f05ffb.js"><link rel="prefetch" href="/assets/status.html.f4c2dde0.js"><link rel="prefetch" href="/assets/file.html.e08b9cd1.js"><link rel="prefetch" href="/assets/linux users.html.ec57678c.js"><link rel="prefetch" href="/assets/linux.html.63efbc5a.js"><link rel="prefetch" href="/assets/redirect_pipe.html.dab5a53e.js"><link rel="prefetch" href="/assets/shell.html.52e4928e.js"><link rel="prefetch" href="/assets/thread_process.html.f54d1cb9.js"><link rel="prefetch" href="/assets/vim.html.7aec5cbb.js"><link rel="prefetch" href="/assets/class.html.de7b9783.js"><link rel="prefetch" href="/assets/data_type.html.9dada957.js"><link rel="prefetch" href="/assets/decorator.html.471b3fdf.js"><link rel="prefetch" href="/assets/enum.html.15187b77.js"><link rel="prefetch" href="/assets/function.html.7e48abcf.js"><link rel="prefetch" href="/assets/generic.html.c3f7aba0.js"><link rel="prefetch" href="/assets/high type.html.5366c25b.js"><link rel="prefetch" href="/assets/interface.html.28e67eb4.js"><link rel="prefetch" href="/assets/namespace_module.html.eeaed8ba.js"><link rel="prefetch" href="/assets/react.html.fa9ceea4.js"><link rel="prefetch" href="/assets/typescript_javascript.html.6ee7c6e3.js"><link rel="prefetch" href="/assets/vue.html.6a1462f2.js"><link rel="prefetch" href="/assets/404.html.0ca41b9f.js"><link rel="prefetch" href="/assets/axios.html.6ee6bbb1.js"><link rel="prefetch" href="/assets/axiosCode.html.80dfb2c7.js"><link rel="prefetch" href="/assets/bind.html.26a2d56f.js"><link rel="prefetch" href="/assets/communication.html.31904a95.js"><link rel="prefetch" href="/assets/components_plugin.html.c6290ae6.js"><link rel="prefetch" href="/assets/cors.html.f463c86b.js"><link rel="prefetch" href="/assets/data.html.473ced5b.js"><link rel="prefetch" href="/assets/data_object_add_attrs.html.f6742910.js"><link rel="prefetch" href="/assets/diff.html.73356fe7.js"><link rel="prefetch" href="/assets/directive.html.aa877e80.js"><link rel="prefetch" href="/assets/error.html.cbe1d60e.js"><link rel="prefetch" href="/assets/filter.html.fec35ad7.js"><link rel="prefetch" href="/assets/first_page_time.html.2c8a8f2b.js"><link rel="prefetch" href="/assets/if_for.html.5096e850.js"><link rel="prefetch" href="/assets/keepalive.html.c72c6e55.js"><link rel="prefetch" href="/assets/key.html.3e8463d1.js"><link rel="prefetch" href="/assets/lifecycle.html.a7f431a9.js"><link rel="prefetch" href="/assets/mixin.html.12e35fb4.js"><link rel="prefetch" href="/assets/modifier.html.f70d98fb.js"><link rel="prefetch" href="/assets/new_vue.html.161e3ce3.js"><link rel="prefetch" href="/assets/nexttick.html.38d4cbde.js"><link rel="prefetch" href="/assets/observable.html.40f72b91.js"><link rel="prefetch" href="/assets/permission.html.1ceed851.js"><link rel="prefetch" href="/assets/show_if.html.857b59f0.js"><link rel="prefetch" href="/assets/slot.html.a4fa0971.js"><link rel="prefetch" href="/assets/spa.html.ea95526f.js"><link rel="prefetch" href="/assets/ssr.html.7301dfeb.js"><link rel="prefetch" href="/assets/structure.html.293974f4.js"><link rel="prefetch" href="/assets/vnode.html.69862d6e.js"><link rel="prefetch" href="/assets/vue.html.1ff6c14f.js"><link rel="prefetch" href="/assets/vue3_vue2.html.581729de.js"><link rel="prefetch" href="/assets/composition.html.b8312a32.js"><link rel="prefetch" href="/assets/goal.html.11b21a85.js"><link rel="prefetch" href="/assets/modal_component.html.31100790.js"><link rel="prefetch" href="/assets/performance.html.2d0d67c6.js"><link rel="prefetch" href="/assets/proxy.html.539de575.js"><link rel="prefetch" href="/assets/treeshaking.html.18049a0a.js"><link rel="prefetch" href="/assets/HMR.html.314c4bab.js"><link rel="prefetch" href="/assets/Loader.html.c30e12b7.js"><link rel="prefetch" href="/assets/Loader_Plugin.html.3fea220e.js"><link rel="prefetch" href="/assets/Plugin.html.eca62507.js"><link rel="prefetch" href="/assets/Rollup_Parcel_snowpack_Vite.html.2ab00287.js"><link rel="prefetch" href="/assets/build_process.html.c3c55b0e.js"><link rel="prefetch" href="/assets/improve_build.html.0e130bea.js"><link rel="prefetch" href="/assets/performance.html.8e30edf7.js"><link rel="prefetch" href="/assets/proxy.html.47979bb5.js"><link rel="prefetch" href="/assets/webpack.html.6f31c37f.js"><link rel="prefetch" href="/assets/中间件.html.7da05904.js"><link rel="prefetch" href="/assets/启动一个koa服务.html.515ae061.js"><link rel="prefetch" href="/assets/日志中间件.html.c872b48a.js"><link rel="prefetch" href="/assets/index.html.385daf47.js"><link rel="prefetch" href="/assets/index.html.7424272a.js"><link rel="prefetch" href="/assets/index.html.eb011684.js"><link rel="prefetch" href="/assets/dict.html.86a524f5.js"><link rel="prefetch" href="/assets/file.html.ebc6a167.js"><link rel="prefetch" href="/assets/func.html.c362de2b.js"><link rel="prefetch" href="/assets/list.html.750c9442.js"><link rel="prefetch" href="/assets/module.html.71a22b5c.js"><link rel="prefetch" href="/assets/set.html.f659bf71.js"><link rel="prefetch" href="/assets/slice.html.88b3fc90.js"><link rel="prefetch" href="/assets/str.html.1d11250c.js"><link rel="prefetch" href="/assets/tuple.html.da9a3060.js"><link rel="prefetch" href="/assets/index.html.1774ea47.js"><link rel="prefetch" href="/assets/index.html.154b0f8c.js"><link rel="prefetch" href="/assets/index.html.e9a2b771.js"><link rel="prefetch" href="/assets/index.html.3a522741.js"><link rel="prefetch" href="/assets/index.html.f870b47b.js"><link rel="prefetch" href="/assets/index.html.c0e4c81b.js"><link rel="prefetch" href="/assets/index.html.71d9042f.js"><link rel="prefetch" href="/assets/index.html.6ba4cc83.js"><link rel="prefetch" href="/assets/index.html.36fcc47d.js"><link rel="prefetch" href="/assets/index.html.fdda89a9.js"><link rel="prefetch" href="/assets/analyze.html.562eb3f2.js"><link rel="prefetch" href="/assets/composition.html.2bfa3c6b.js"><link rel="prefetch" href="/assets/create.html.2ba45510.js"><link rel="prefetch" href="/assets/vue-3.3.html.ebde8b3b.js"><link rel="prefetch" href="/assets/index.html.ee204922.js"><link rel="prefetch" href="/assets/index.html.06ad3915.js"><link rel="prefetch" href="/assets/index.html.3004f3e1.js"><link rel="prefetch" href="/assets/base.html.70d20523.js"><link rel="prefetch" href="/assets/clean.html.dc2156ea.js"><link rel="prefetch" href="/assets/config.html.c187a38f.js"><link rel="prefetch" href="/assets/css.html.0d9a48f9.js"><link rel="prefetch" href="/assets/development.html.3459de05.js"><link rel="prefetch" href="/assets/font.html.04d3edf6.js"><link rel="prefetch" href="/assets/html.html.339d17e1.js"><link rel="prefetch" href="/assets/image.html.bb181e38.js"><link rel="prefetch" href="/assets/javascript.html.ddab5878.js"><link rel="prefetch" href="/assets/optimizeCss.html.ff6d9888.js"><link rel="prefetch" href="/assets/output.html.5dee1be6.js"><link rel="prefetch" href="/assets/production.html.eca71a86.js"><link rel="prefetch" href="/assets/serve.html.26c172c8.js"><link rel="prefetch" href="/assets/index.html.06cfccd5.js"><link rel="prefetch" href="/assets/vue-cli.html.36a8a14d.js"><link rel="prefetch" href="/assets/index.html.ecfdb3d8.js"><link rel="prefetch" href="/assets/enhanceExperience.html.8ca4496d.js"><link rel="prefetch" href="/assets/liftingSpeed.html.d0d71d72.js"><link rel="prefetch" href="/assets/optimizePerformance.html.2e176642.js"><link rel="prefetch" href="/assets/reduceVolume.html.051e832a.js"><link rel="prefetch" href="/assets/summary.html.5aa4e483.js"><link rel="prefetch" href="/assets/404.html.8c7841a9.js">
    <link rel="stylesheet" href="/assets/style.f4d22aab.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">胡熙国</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="http://nuxt.yunog.cn" rel="noopener noreferrer" target="_blank" aria-label="SSR入门"><!--[--><!--]--> SSR入门 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="http://echart.yunog.cn" rel="noopener noreferrer" target="_blank" aria-label="echart-demo"><!--[--><!--]--> echart-demo <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="http://music.yunog.cn" rel="noopener noreferrer" target="_blank" aria-label="个人音乐"><!--[--><!--]--> 个人音乐 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/huxiguo" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="http://nuxt.yunog.cn" rel="noopener noreferrer" target="_blank" aria-label="SSR入门"><!--[--><!--]--> SSR入门 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="http://echart.yunog.cn" rel="noopener noreferrer" target="_blank" aria-label="echart-demo"><!--[--><!--]--> echart-demo <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="http://music.yunog.cn" rel="noopener noreferrer" target="_blank" aria-label="个人音乐"><!--[--><!--]--> 个人音乐 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/huxiguo" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">HTML <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/HTML/doctype.html" class="sidebar-item" aria-label="DOCTYPE"><!--[--><!--]--> DOCTYPE <!--[--><!--]--></a><!----></li><li><a href="/HTML/HTML%E8%AF%AD%E4%B9%89%E5%8C%96.html" class="sidebar-item" aria-label="HTML 语义化"><!--[--><!--]--> HTML 语义化 <!--[--><!--]--></a><!----></li><li><a href="/HTML/Cookie%E4%B8%8ESession.html" class="sidebar-item" aria-label="Cookie 与 Session"><!--[--><!--]--> Cookie 与 Session <!--[--><!--]--></a><!----></li><li><a href="/HTML/HTML5%E6%96%B0%E7%89%B9%E6%80%A7.html" class="sidebar-item" aria-label="HTML5 新特性"><!--[--><!--]--> HTML5 新特性 <!--[--><!--]--></a><!----></li><li><a href="/HTML/LocalStorage%E4%B8%8ESessionStorage.html" class="sidebar-item" aria-label="localStorage 与 sessionStorage"><!--[--><!--]--> localStorage 与 sessionStorage <!--[--><!--]--></a><!----></li><li><a href="/HTML/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88.html" class="sidebar-item" aria-label="前端性能优化方案"><!--[--><!--]--> 前端性能优化方案 <!--[--><!--]--></a><!----></li><li><a href="/HTML/DOM%E5%92%8CBOM%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="DOM 和 BOM 的区别"><!--[--><!--]--> DOM 和 BOM 的区别 <!--[--><!--]--></a><!----></li><li><a href="/HTML/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0.html" class="sidebar-item" aria-label="行内元素和块级元素"><!--[--><!--]--> 行内元素和块级元素 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">CSS <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/CSS/CSS%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BBEM.html" class="sidebar-item" aria-label="CSS 架构模式之 BEM"><!--[--><!--]--> CSS 架构模式之 BEM <!--[--><!--]--></a><!----></li><li><a href="/CSS/CSS%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F.html" class="sidebar-item" aria-label="CSS 引入方式"><!--[--><!--]--> CSS 引入方式 <!--[--><!--]--></a><!----></li><li><a href="/CSS/css.html" class="sidebar-item" aria-label="CSS基础"><!--[--><!--]--> CSS基础 <!--[--><!--]--></a><!----></li><li><a href="/CSS/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html" class="sidebar-item" aria-label="CSS 盒子模型"><!--[--><!--]--> CSS 盒子模型 <!--[--><!--]--></a><!----></li><li><a href="/CSS/CSS%E9%80%89%E6%8B%A9%E5%99%A8.html" class="sidebar-item" aria-label="CSS 选择器"><!--[--><!--]--> CSS 选择器 <!--[--><!--]--></a><!----></li><li><a href="/CSS/CSS%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7.html" class="sidebar-item" aria-label="CSS 优先级"><!--[--><!--]--> CSS 优先级 <!--[--><!--]--></a><!----></li><li><a href="/CSS/Position%E5%AE%9A%E4%BD%8D.html" class="sidebar-item" aria-label="Position 定位"><!--[--><!--]--> Position 定位 <!--[--><!--]--></a><!----></li><li><a href="/CSS/Float%E6%B5%AE%E5%8A%A8.html" class="sidebar-item" aria-label="Float 浮动"><!--[--><!--]--> Float 浮动 <!--[--><!--]--></a><!----></li><li><a href="/CSS/Flex%E5%B8%83%E5%B1%80.html" class="sidebar-item" aria-label="Flex 布局"><!--[--><!--]--> Flex 布局 <!--[--><!--]--></a><!----></li><li><a href="/CSS/Grid%E5%B8%83%E5%B1%80.html" class="sidebar-item" aria-label="Grid 布局"><!--[--><!--]--> Grid 布局 <!--[--><!--]--></a><!----></li><li><a href="/CSS/%E5%B8%83%E5%B1%80%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD.html" class="sidebar-item" aria-label="垂直居中"><!--[--><!--]--> 垂直居中 <!--[--><!--]--></a><!----></li><li><a href="/CSS/%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80.html" class="sidebar-item" aria-label="实现三栏布局"><!--[--><!--]--> 实现三栏布局 <!--[--><!--]--></a><!----></li><li><a href="/CSS/CSS%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95.html" class="sidebar-item" aria-label="CSS 隐藏元素的方法"><!--[--><!--]--> CSS 隐藏元素的方法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">javaScript <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/js/ES6%E6%96%B0%E7%89%B9%E6%80%A7.html" class="sidebar-item" aria-label="ES6 新特性"><!--[--><!--]--> ES6 新特性 <!--[--><!--]--></a><!----></li><li><a href="/js/JS%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.html" class="sidebar-item" aria-label="JavaScript 变量提升"><!--[--><!--]--> JavaScript 变量提升 <!--[--><!--]--></a><!----></li><li><a href="/js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html" class="sidebar-item" aria-label="作用域与作用域链"><!--[--><!--]--> 作用域与作用域链 <!--[--><!--]--></a><!----></li><li><a href="/js/data_type.html" class="sidebar-item" aria-label="数据类型"><!--[--><!--]--> 数据类型 <!--[--><!--]--></a><!----></li><li><a href="/js/type_conversion.html" class="sidebar-item" aria-label="类型转化"><!--[--><!--]--> 类型转化 <!--[--><!--]--></a><!----></li><li><a href="/js/eq.html" class="sidebar-item" aria-label="===与==的区别"><!--[--><!--]--> ===与==的区别 <!--[--><!--]--></a><!----></li><li><a href="/js/inheritance.html" class="sidebar-item" aria-label="继承"><!--[--><!--]--> 继承 <!--[--><!--]--></a><!----></li><li><a href="/js/copy.html" class="sidebar-item" aria-label="深拷贝与浅拷贝"><!--[--><!--]--> 深拷贝与浅拷贝 <!--[--><!--]--></a><!----></li><li><a href="/js/array.html" class="sidebar-item" aria-label="数组应用"><!--[--><!--]--> 数组应用 <!--[--><!--]--></a><!----></li><li><a href="/js/Symbol.html" class="sidebar-item" aria-label="Symbol"><!--[--><!--]--> Symbol <!--[--><!--]--></a><!----></li><li><a href="/js/promise.html" class="sidebar-item" aria-label="promise"><!--[--><!--]--> promise <!--[--><!--]--></a><!----></li><li><a href="/js/defineProperty.html" class="sidebar-item" aria-label="defineProperty"><!--[--><!--]--> defineProperty <!--[--><!--]--></a><!----></li><li><a href="/js/Js%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html" class="sidebar-item" aria-label="Js 模块化导入导出"><!--[--><!--]--> Js 模块化导入导出 <!--[--><!--]--></a><!----></li><li><a href="/js/let%E4%B8%8Econst.html" class="sidebar-item" aria-label="let 与 const"><!--[--><!--]--> let 与 const <!--[--><!--]--></a><!----></li><li><a href="/js/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.html" class="sidebar-item" aria-label="防抖与节流"><!--[--><!--]--> 防抖与节流 <!--[--><!--]--></a><!----></li><li><a href="/js/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="sidebar-item" aria-label="函数声明与函数表达式"><!--[--><!--]--> 函数声明与函数表达式 <!--[--><!--]--></a><!----></li><li><a href="/js/Js%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html" class="sidebar-item" aria-label="Js 箭头函数"><!--[--><!--]--> Js 箭头函数 <!--[--><!--]--></a><!----></li><li><a href="/js/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html" class="sidebar-item" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a><!----></li><li><a href="/js/uniapp-websocket.html" class="sidebar-item" aria-label="uniapp 建立 websocket 连接"><!--[--><!--]--> uniapp 建立 websocket 连接 <!--[--><!--]--></a><!----></li><li><a href="/js/%E5%A4%A7%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E4%B8%8A%E4%BC%A0.html" class="sidebar-item" aria-label="大文件断点续传"><!--[--><!--]--> 大文件断点续传 <!--[--><!--]--></a><!----></li><li><a href="/js/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0.html" class="sidebar-item" aria-label="上拉加载下拉刷新"><!--[--><!--]--> 上拉加载下拉刷新 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Vue <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">vue2 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vue/vue2.html" class="sidebar-item" aria-label="Vue2"><!--[--><!--]--> Vue2 <!--[--><!--]--></a><!----></li><li><a href="/vue/communication.html" class="sidebar-item" aria-label="组件通信"><!--[--><!--]--> 组件通信 <!--[--><!--]--></a><!----></li><li><a href="/vue/proxy.html" class="sidebar-item" aria-label="跨域与代理"><!--[--><!--]--> 跨域与代理 <!--[--><!--]--></a><!----></li><li><a href="/vue/vuex.html" class="sidebar-item" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a><!----></li><li><a href="/vue/vueRouter.html" class="sidebar-item" aria-label="vueRouter"><!--[--><!--]--> vueRouter <!--[--><!--]--></a><!----></li><li><a href="/vue/VRouter.html" class="sidebar-item" aria-label="vueRouter 详"><!--[--><!--]--> vueRouter 详 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">vue3 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/vue/vue3/" class="sidebar-item" aria-label="介绍"><!--[--><!--]--> 介绍 <!--[--><!--]--></a><!----></li><li><a href="/vue/vue3/create.html" class="sidebar-item" aria-label="创建项目"><!--[--><!--]--> 创建项目 <!--[--><!--]--></a><!----></li><li><a href="/vue/vue3/analyze.html" class="sidebar-item" aria-label="分析项目"><!--[--><!--]--> 分析项目 <!--[--><!--]--></a><!----></li><li><a href="/vue/vue3/composition.html" class="sidebar-item" aria-label="组合式API"><!--[--><!--]--> 组合式API <!--[--><!--]--></a><!----></li><li><a href="/vue/vue3/vue-3.3.html" class="sidebar-item" aria-label="Vue 3.3"><!--[--><!--]--> Vue 3.3 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/vue/SPA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.html" class="sidebar-item" aria-label="SPA 单页应用的优缺点"><!--[--><!--]--> SPA 单页应用的优缺点 <!--[--><!--]--></a><!----></li><li><a href="/vue/MVVM.html" class="sidebar-item" aria-label="MVVM 模式的理解"><!--[--><!--]--> MVVM 模式的理解 <!--[--><!--]--></a><!----></li><li><a href="/vue/Vue2%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html" class="sidebar-item" aria-label="Vue2 双向数据绑定"><!--[--><!--]--> Vue2 双向数据绑定 <!--[--><!--]--></a><!----></li><li><a href="/vue/Vue_cli.html" class="sidebar-item" aria-label="Vue Cli"><!--[--><!--]--> Vue Cli <!--[--><!--]--></a><!----></li><li><a href="/vue/vite" class="sidebar-item" aria-label="Vite"><!--[--><!--]--> Vite <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">React <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/React/base/accidence.html" class="sidebar-item" aria-label="React 基础"><!--[--><!--]--> React 基础 <!--[--><!--]--></a><!----></li><li><a href="/React/base/jsx.html" class="sidebar-item" aria-label="JSX"><!--[--><!--]--> JSX <!--[--><!--]--></a><!----></li><li><a href="/React/base/component.html" class="sidebar-item" aria-label="React 组件"><!--[--><!--]--> React 组件 <!--[--><!--]--></a><!----></li><li><a href="/React/base/event.html" class="sidebar-item" aria-label="React 事件处理"><!--[--><!--]--> React 事件处理 <!--[--><!--]--></a><!----></li><li><a href="/React/base/state.html" class="sidebar-item" aria-label="状态组件"><!--[--><!--]--> 状态组件 <!--[--><!--]--></a><!----></li><li><a href="/React/base/Props.html" class="sidebar-item" aria-label="通过 Props 传递数据"><!--[--><!--]--> 通过 Props 传递数据 <!--[--><!--]--></a><!----></li><li><a href="/React/base/Refs.html" class="sidebar-item" aria-label="refs"><!--[--><!--]--> refs <!--[--><!--]--></a><!----></li><li><a href="/React/base/active.html" class="sidebar-item" aria-label="组件生命周期"><!--[--><!--]--> 组件生命周期 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">TypeScript <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/TypeScript/base.html" class="sidebar-item" aria-label="TypeScript 基础"><!--[--><!--]--> TypeScript 基础 <!--[--><!--]--></a><!----></li><li><a href="/TypeScript/type.html" class="sidebar-item" aria-label="常用类型"><!--[--><!--]--> 常用类型 <!--[--><!--]--></a><!----></li><li><a href="/TypeScript/high_type.html" class="sidebar-item" aria-label="高级类型"><!--[--><!--]--> 高级类型 <!--[--><!--]--></a><!----></li><li><a href="/TypeScript/typeFile.html" class="sidebar-item" aria-label="类型声明文件"><!--[--><!--]--> 类型声明文件 <!--[--><!--]--></a><!----></li><li><a href="/TypeScript/config.html" class="sidebar-item" aria-label="编译配置文件"><!--[--><!--]--> 编译配置文件 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">前端测试 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/testing/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95.html" class="sidebar-item" aria-label="前端测试"><!--[--><!--]--> 前端测试 <!--[--><!--]--></a><!----></li><li><a href="/testing/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html" class="sidebar-item" aria-label="单元测试"><!--[--><!--]--> 单元测试 <!--[--><!--]--></a><!----></li><li><a href="/testing/e2e.html" class="sidebar-item" aria-label="端到端测试"><!--[--><!--]--> 端到端测试 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">设计模式 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/OS/patterns/简单工厂模式" class="sidebar-item" aria-label="patterns/简单工厂模式"><!--[--><!--]--> patterns/简单工厂模式 <!--[--><!--]--></a><!----></li><li><a href="/OS/patterns/工厂方法模式" class="sidebar-item" aria-label="patterns/工厂方法模式"><!--[--><!--]--> patterns/工厂方法模式 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Node <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/node/api_serve.html" class="sidebar-item" aria-label="api开发"><!--[--><!--]--> api开发 <!--[--><!--]--></a><!----></li><li><a href="/node/AST.html" class="sidebar-item" aria-label="AST"><!--[--><!--]--> AST <!--[--><!--]--></a><!----></li><li><a href="/node/webpack-loader.html" class="sidebar-item" aria-label="webpack 自定义 loader"><!--[--><!--]--> webpack 自定义 loader <!--[--><!--]--></a><!----></li><li><a href="/node/webpack-plugin.html" class="sidebar-item" aria-label="webpack 自定义 plugin"><!--[--><!--]--> webpack 自定义 plugin <!--[--><!--]--></a><!----></li><li><a href="/node/koa/%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAkoa%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="启动一个kao服务"><!--[--><!--]--> 启动一个kao服务 <!--[--><!--]--></a><!----></li><li><a href="/node/koa/%E6%97%A5%E5%BF%97%E4%B8%AD%E9%97%B4%E4%BB%B6.html" class="sidebar-item" aria-label="/node/koa/日志中间件"><!--[--><!--]--> /node/koa/日志中间件 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">nest <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/nestjs/%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B.html" class="sidebar-item" aria-label="Nest 起步"><!--[--><!--]--> Nest 起步 <!--[--><!--]--></a><!----></li><li><a href="/nestjs/cli%E5%91%BD%E4%BB%A4.html" class="sidebar-item" aria-label="nest cli 常用命令"><!--[--><!--]--> nest cli 常用命令 <!--[--><!--]--></a><!----></li><li><a href="/nestjs/%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html" class="sidebar-item" aria-label="接口版本控制"><!--[--><!--]--> 接口版本控制 <!--[--><!--]--></a><!----></li><li><a href="/nestjs/%E6%8E%A7%E5%88%B6%E5%99%A8.html" class="sidebar-item" aria-label="控制器"><!--[--><!--]--> 控制器 <!--[--><!--]--></a><!----></li><li><a href="/nestjs/session.html" class="sidebar-item" aria-label="session"><!--[--><!--]--> session <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">leetcode <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/leetcode/maximum-split-of-positive-even-integers.html" class="sidebar-item" aria-label="拆分成最多数目的正偶数之和"><!--[--><!--]--> 拆分成最多数目的正偶数之和 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/remove-digit-from-number-to-maximize-result.html" class="sidebar-item" aria-label="移除指定数字得到的最大结果"><!--[--><!--]--> 移除指定数字得到的最大结果 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/valid-palindrome.html" class="sidebar-item" aria-label="验证回文串"><!--[--><!--]--> 验证回文串 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.html" class="sidebar-item" aria-label="视频拼接"><!--[--><!--]--> 视频拼接 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE.html" class="sidebar-item" aria-label="1281 整数的各位积和之差"><!--[--><!--]--> 1281 整数的各位积和之差 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html" class="sidebar-item" aria-label="无重复字符的最长子串"><!--[--><!--]--> 无重复字符的最长子串 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E4%BB%BB%E6%84%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html" class="sidebar-item" aria-label="任意子数组和的绝对值的最大值"><!--[--><!--]--> 任意子数组和的绝对值的最大值 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html" class="sidebar-item" aria-label="有效的括号"><!--[--><!--]--> 有效的括号 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html" class="sidebar-item" aria-label="移除元素"><!--[--><!--]--> 移除元素 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87.html" class="sidebar-item" aria-label="找出字符串中第一个匹配项的下标"><!--[--><!--]--> 找出字符串中第一个匹配项的下标 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6.html" class="sidebar-item" aria-label="最后一个单词的长度"><!--[--><!--]--> 最后一个单词的长度 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/%E5%8A%A0%E4%B8%80.html" class="sidebar-item" aria-label="加一"><!--[--><!--]--> 加一 <!--[--><!--]--></a><!----></li><li><a href="/leetcode/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html" class="sidebar-item" aria-label="x 的平方根"><!--[--><!--]--> x 的平方根 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">工程化 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/Webpack/base/" class="sidebar-item" aria-label="前言"><!--[--><!--]--> 前言 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/base.html" class="sidebar-item" aria-label="基本使用"><!--[--><!--]--> 基本使用 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/config.html" class="sidebar-item" aria-label="基本配置"><!--[--><!--]--> 基本配置 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/development.html" class="sidebar-item" aria-label="开发模式"><!--[--><!--]--> 开发模式 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/css.html" class="sidebar-item" aria-label="处理样式资源"><!--[--><!--]--> 处理样式资源 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/image.html" class="sidebar-item" aria-label="处理图片资源"><!--[--><!--]--> 处理图片资源 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/output.html" class="sidebar-item" aria-label="修改输出资源的名称和路径"><!--[--><!--]--> 修改输出资源的名称和路径 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/clean.html" class="sidebar-item" aria-label="自动清空上次打包资源"><!--[--><!--]--> 自动清空上次打包资源 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/font.html" class="sidebar-item" aria-label="自动清空上次打包资源"><!--[--><!--]--> 自动清空上次打包资源 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/javascript.html" class="sidebar-item" aria-label="处理 js 资源"><!--[--><!--]--> 处理 js 资源 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/html.html" class="sidebar-item" aria-label="处理 Html 资源"><!--[--><!--]--> 处理 Html 资源 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/serve.html" class="sidebar-item" aria-label="开发服务器&amp;自动化"><!--[--><!--]--> 开发服务器&amp;自动化 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/production.html" class="sidebar-item" aria-label="生产模式"><!--[--><!--]--> 生产模式 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/base/optimizeCss.html" class="sidebar-item" aria-label="Css 处理"><!--[--><!--]--> Css 处理 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/senior/" class="sidebar-item" aria-label="优化"><!--[--><!--]--> 优化 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/senior/enhanceExperience.html" class="sidebar-item" aria-label="提升开发体验"><!--[--><!--]--> 提升开发体验 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/senior/liftingSpeed.html" class="sidebar-item" aria-label="提升打包构建速度"><!--[--><!--]--> 提升打包构建速度 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/senior/reduceVolume.html" class="sidebar-item" aria-label="减少代码体积"><!--[--><!--]--> 减少代码体积 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/senior/optimizePerformance.html" class="sidebar-item" aria-label="优化代码运行性能"><!--[--><!--]--> 优化代码运行性能 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/senior/summary.html" class="sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/project/" class="sidebar-item" aria-label="搭建脚手架"><!--[--><!--]--> 搭建脚手架 <!--[--><!--]--></a><!----></li><li><a href="/project/Webpack/project/vue-cli.html" class="sidebar-item" aria-label="vue-cli"><!--[--><!--]--> vue-cli <!--[--><!--]--></a><!----></li><li><a href="/project/Vite/BuildTools/" class="sidebar-item" aria-label="什么是构建工具"><!--[--><!--]--> 什么是构建工具 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">SSR <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/SSR/Node/vue3NodeSSR.html" class="sidebar-item" aria-label="node搭建 vue3 SSR"><!--[--><!--]--> node搭建 vue3 SSR <!--[--><!--]--></a><!----></li><li><a href="/SSR/Node/SSRHydration.html" class="sidebar-item" aria-label="SSR Hydration"><!--[--><!--]--> SSR Hydration <!--[--><!--]--></a><!----></li><li><a href="/SSR/Node/vueSSRRouter.html" class="sidebar-item" aria-label="SSR Router"><!--[--><!--]--> SSR Router <!--[--><!--]--></a><!----></li><li><a href="/SSR/Node/vueSSRPinia.html" class="sidebar-item" aria-label="SSR Pinia"><!--[--><!--]--> SSR Pinia <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/what.html" class="sidebar-item" aria-label="什么是Nuxt"><!--[--><!--]--> 什么是Nuxt <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/start.html" class="sidebar-item" aria-label="start Nuxt"><!--[--><!--]--> start Nuxt <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/directory.html" class="sidebar-item" aria-label="目录结构"><!--[--><!--]--> 目录结构 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/nuxtConfig.html" class="sidebar-item" aria-label="nuxt.config.ts"><!--[--><!--]--> nuxt.config.ts <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/components.html" class="sidebar-item" aria-label="内置组件"><!--[--><!--]--> 内置组件 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/css.html" class="sidebar-item" aria-label="样式"><!--[--><!--]--> 样式 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/assest.html" class="sidebar-item" aria-label="资源"><!--[--><!--]--> 资源 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/page.html" class="sidebar-item" aria-label="页面"><!--[--><!--]--> 页面 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/router.html" class="sidebar-item" aria-label="路由"><!--[--><!--]--> 路由 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/layout.html" class="sidebar-item" aria-label="布局"><!--[--><!--]--> 布局 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/randerMode.html" class="sidebar-item" aria-label="渲染模式"><!--[--><!--]--> 渲染模式 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/plugin.html" class="sidebar-item" aria-label="插件"><!--[--><!--]--> 插件 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/lifecycle.html" class="sidebar-item" aria-label="生命周期"><!--[--><!--]--> 生命周期 <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/fetch.html" class="sidebar-item" aria-label="fetch"><!--[--><!--]--> fetch <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/api.html" class="sidebar-item" aria-label="api"><!--[--><!--]--> api <!--[--><!--]--></a><!----></li><li><a href="/SSR/Nuxt/state.html" class="sidebar-item" aria-label="state"><!--[--><!--]--> state <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">Git <span class="right arrow"></span></p><!----></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">指令 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/Git/git.html" class="sidebar-item" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a><!----></li><li><a href="/Git/github.html" class="sidebar-item" aria-label="Github"><!--[--><!--]--> Github <!--[--><!--]--></a><!----></li><li><a href="/command/linux_command.html" class="sidebar-item" aria-label="Linux 命令"><!--[--><!--]--> Linux 命令 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">js面试题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview-js/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="箭头函数和普通函数的区别"><!--[--><!--]--> 箭头函数和普通函数的区别 <!--[--><!--]--></a><!----></li><li><a href="/interview-js/JS%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84.html" class="sidebar-item" aria-label="JS 遍历数组方式"><!--[--><!--]--> JS 遍历数组方式 <!--[--><!--]--></a><!----></li><li><a href="/interview-js/JS%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1.html" class="sidebar-item" aria-label="JS 遍历对象"><!--[--><!--]--> JS 遍历对象 <!--[--><!--]--></a><!----></li><li><a href="/interview-js/webworker.html" class="sidebar-item" aria-label="web worker"><!--[--><!--]--> web worker <!--[--><!--]--></a><!----></li><li><a href="/interview-js/ajax.html" class="sidebar-item" aria-label="Ajax"><!--[--><!--]--> Ajax <!--[--><!--]--></a><!----></li><li><a href="/interview-js/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" class="sidebar-item" aria-label="函数式编程的理解"><!--[--><!--]--> 函数式编程的理解 <!--[--><!--]--></a><!----></li><li><a href="/interview-js/addEventListener.html" class="sidebar-item" aria-label="addEventListener"><!--[--><!--]--> addEventListener <!--[--><!--]--></a><!----></li><li><a href="/interview-js/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95.html" class="sidebar-item" aria-label="判断数组的方法"><!--[--><!--]--> 判断数组的方法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">CSS面试题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview-css/%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92.html" class="sidebar-item" aria-label="重绘和重排"><!--[--><!--]--> 重绘和重排 <!--[--><!--]--></a><!----></li><li><a href="/interview-css/%E5%8A%A8%E7%94%BB.html" class="sidebar-item" aria-label="动画"><!--[--><!--]--> 动画 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">浏览器面试题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview-broswer/cookie.html" class="sidebar-item" aria-label="cookie"><!--[--><!--]--> cookie <!--[--><!--]--></a><!----></li><li><a href="/interview-broswer/webWorker.html" class="sidebar-item" aria-label="Web Worker"><!--[--><!--]--> Web Worker <!--[--><!--]--></a><!----></li><li><a href="/interview-broswer/BOM%E5%AF%B9%E8%B1%A1.html" class="sidebar-item" aria-label="BOM 对象"><!--[--><!--]--> BOM 对象 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">网络面试题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview-network/TCP-IP%E5%8D%8F%E8%AE%AE.html" class="sidebar-item" aria-label="TCP/IP 协议"><!--[--><!--]--> TCP/IP 协议 <!--[--><!--]--></a><!----></li><li><a href="/interview-network/http%E7%8A%B6%E6%80%81%E7%A0%81.html" class="sidebar-item" aria-label="HTTP 常见的状态码"><!--[--><!--]--> HTTP 常见的状态码 <!--[--><!--]--></a><!----></li><li><a href="/interview-network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html" class="sidebar-item" aria-label="TCP 三次握手四次挥手"><!--[--><!--]--> TCP 三次握手四次挥手 <!--[--><!--]--></a><!----></li><li><a href="/interview-network/node_tcp.html" class="sidebar-item" aria-label="node tcp服务"><!--[--><!--]--> node tcp服务 <!--[--><!--]--></a><!----></li><li><a href="/interview-network/node_udp.html" class="sidebar-item" aria-label="UDP"><!--[--><!--]--> UDP <!--[--><!--]--></a><!----></li><li><a href="/interview-network/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82.html" class="sidebar-item" aria-label="网络请求"><!--[--><!--]--> 网络请求 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">框架面试题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview-frame/npmInstall.html" class="sidebar-item" aria-label="npm install 发生了啥"><!--[--><!--]--> npm install 发生了啥 <!--[--><!--]--></a><!----></li><li><a href="/interview-frame/ref%E5%92%8Creactive%E5%8C%BA%E5%88%AB.html" class="sidebar-item" aria-label="ref 和 reactive 异同"><!--[--><!--]--> ref 和 reactive 异同 <!--[--><!--]--></a><!----></li><li><a href="/interview-frame/npm%E5%92%8Cyarn%E5%92%8Cpnpm%E5%AF%B9%E6%AF%94.html" class="sidebar-item" aria-label="npm yarn pnpm 对比"><!--[--><!--]--> npm yarn pnpm 对比 <!--[--><!--]--></a><!----></li><li><a href="/interview-frame/ref-toRef-toRefs.html" class="sidebar-item" aria-label="如何理解 ref、toRef 和 toRefs"><!--[--><!--]--> 如何理解 ref、toRef 和 toRefs <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">手写代码题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview-code/apply-call-bind.html" class="sidebar-item" aria-label="手写 apply call bind"><!--[--><!--]--> 手写 apply call bind <!--[--><!--]--></a><!----></li><li><a href="/interview-code/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" class="sidebar-item" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a><!----></li><li><a href="/interview-code/promise.html" class="sidebar-item" aria-label="手动实现Promise"><!--[--><!--]--> 手动实现Promise <!--[--><!--]--></a><!----></li><li><a href="/interview-code/%E8%8E%B7%E5%8F%96%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%89%8D%E4%B8%89%E7%9A%84tag.html" class="sidebar-item" aria-label="获取html里面出现次数前三的tag标签"><!--[--><!--]--> 获取html里面出现次数前三的tag标签 <!--[--><!--]--></a><!----></li><li><a href="/interview-code/sort.html" class="sidebar-item" aria-label="使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进 行排序，输出结果"><!--[--><!--]--> 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进 行排序，输出结果 <!--[--><!--]--></a><!----></li><li><a href="/interview-code/object%E5%B1%9E%E6%80%A7.html" class="sidebar-item" aria-label="对象属性自定义"><!--[--><!--]--> 对象属性自定义 <!--[--><!--]--></a><!----></li><li><a href="/interview-code/%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC.html" class="sidebar-item" aria-label="连续赋值"><!--[--><!--]--> 连续赋值 <!--[--><!--]--></a><!----></li><li><a href="/interview-code/%E5%AF%B9%E8%B1%A1%E6%8C%89%E8%A6%81%E6%B1%82%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84.html" class="sidebar-item" aria-label="对象按要求填充数组"><!--[--><!--]--> 对象按要求填充数组 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">element-plus 工程学习 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/element-plus/%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96.html" class="sidebar-item" aria-label="组件库工程化"><!--[--><!--]--> 组件库工程化 <!--[--><!--]--></a><!----></li><li><a href="/element-plus/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%84%E4%BB%B6%E5%BA%93.html" class="sidebar-item" aria-label="创建组件库"><!--[--><!--]--> 创建组件库 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">面试 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview-exp/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="sidebar-item" aria-label="高频面试题"><!--[--><!--]--> 高频面试题 <!--[--><!--]--></a><!----></li><li><a href="/interview-exp/showmebug.html" class="sidebar-item" aria-label="showmebug 面试题"><!--[--><!--]--> showmebug 面试题 <!--[--><!--]--></a><!----></li><li><a href="/interview-exp/2023-07-12.html" class="sidebar-item" aria-label="2023-07-12 面试总结"><!--[--><!--]--> 2023-07-12 面试总结 <!--[--><!--]--></a><!----></li><li><a href="/interview-exp/2023-07-19.html" class="sidebar-item" aria-label="2023-07-19 面试"><!--[--><!--]--> 2023-07-19 面试 <!--[--><!--]--></a><!----></li><li><a href="/interview-exp/2023-07-20.html" class="sidebar-item" aria-label="2023-07-20 面试"><!--[--><!--]--> 2023-07-20 面试 <!--[--><!--]--></a><!----></li><li><a href="/interview-exp/2023-07-25.html" class="sidebar-item" aria-label="2023-07-25 面试"><!--[--><!--]--> 2023-07-25 面试 <!--[--><!--]--></a><!----></li><li><a href="/interview-exp/2023-07-25-fd.html" class="sidebar-item" aria-label="2023-07-25 面试 fd"><!--[--><!--]--> 2023-07-25 面试 fd <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h1><h2 id="第一章操作系统" tabindex="-1"><a class="header-anchor" href="#第一章操作系统" aria-hidden="true">#</a> 第一章操作系统</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><ul><li>一组能够有效地组织和管理计算机硬件和软件资源，合理的对各类作业进行调度，以及方便用户使用的程序集合</li></ul><h3 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h3><ol><li>方便性</li><li>有效性</li><li>可扩充性</li><li>开放性</li></ol><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h3><ol><li>作为用户与计算机硬件之间的接口</li><li>作为计算机系统资源的管理者</li><li>实现对计算机资源的抽象</li></ol><h3 id="发展过程" tabindex="-1"><a class="header-anchor" href="#发展过程" aria-hidden="true">#</a> 发展过程</h3><ol><li><p>批处理系统：：用户将作业交给系统操作员，系统操作员将许多用户的作业组成一批作业，之后输入到计算机中，在系统中形成一个自动转接的连续的作业流，然后启动操作系统，系统自动、依次执行每个作业。最后由操作员将作业结果交给用户。</p></li><li><p>单道批处理系统：系统对作业的处理是成批进行的，但内存中始终保持一道作业。该系统是在解决人机矛盾和 CPU 与 I/O 设备速率不匹配的矛盾中形成的。</p><ul><li>顺序性：磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序，在正常情况下应完全相同，亦即先调入内存的作业先完成。</li><li>单道性：内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</li><li>自动性：在顺利的情况下，在磁带上的一批作业能自动地逐个依次运行，而无需人工干预。</li></ul><ol start="2"><li><p>多道批处理系统：多道程序设计技术允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在 CPU 中运行，它们共享系统中的各种硬、软件资源。当一道程序因 I/O 请求而暂停运行时，CPU 便立即转去运行另一道程序。它没有用某些机制提高某一技术方面的瓶颈问题，而是让系统的各个组成部分都尽量去“忙”，花费很少时间去切换任务，达到了系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。</p><ul><li><p>多道：计算机内存中同时存放多道相互独立的程序。</p></li><li><p>宏观上并行：同时进入系统的多道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕。</p></li><li><p>微观上串行：内存中的多道程序轮流占有 CPU，交替执行。</p></li><li><p>优点：资源利用率高，系统吞吐量大</p></li><li><p>缺点：平均周转时间长，无交互能力</p></li><li><p>需要解决的问题：</p><ul><li>处理机争用问题</li></ul></li><li><p>内存分配和保护问题</p><ul><li>I/O 设备分配问题</li></ul></li><li><p>文件组织和管理问题</p><ul><li>作业管理问题</li></ul></li><li><p>用户与系统的接口问题</p></li></ul></li></ol></li><li><pre><code>            分时操作系统：一台主机连接了若干个终端，每个终端有一个用户在使用。用户交互式地向系统提出命令请求，系统接受每个用户的命令，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。用户根据上步结果发出下道命。分时操作系统将CPU的时间划分成若干个片段，称为时间片。操作系统以时间片为单位，轮流为每个终端用户服务。每个用户轮流使用一个时间片而使每个用户并不感到有别的用户存在。分时系统具有多路性、交互性、“独占”性和及时性的特征。多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。“独占”性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。及时性指，系统对用户提出的请求及时响应。
</code></pre><ul><li>特点： <ul><li>多路性（同时性）：指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li><li>交互性：用户能够方便地与系统进行人-机对话，即用户通过终端釆用人 4^1 对话的方式直接控制程序运行，与同程序进行交互。</li><li>独立性：系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</li><li>及时性：用户请求能在很短时间内获得响应。分时系统釆用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</li><li>解决了人机交互问题</li></ul></li></ul></li><li><p>实时操作系统：实时操作系统是指使计算机能及时响应外部事件的请求在规定的严格时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致地工作的操作系统。实时操作系统要追求的目标是：对外部请求在严格时间范围内做出反应，有高可靠性和完整性。</p></li></ol><h3 id="操作系统的基本特点" tabindex="-1"><a class="header-anchor" href="#操作系统的基本特点" aria-hidden="true">#</a> 操作系统的基本特点</h3><ol><li><p>并发与并行</p><ol><li>并行：两个或多个事件在同一时刻发生</li><li>并发：两个或多个事件在同一时间间隔发生</li></ol><ul><li>并发是提高系统资源利用率，增加系统的吞吐量的主要手段</li><li>单处理机并发执行，多处理机并发/并行执行</li><li>引入进程机制可以实现多进程并发执行</li></ul></li><li><p>共享：资源共享也称为资源复用，是指操作系统中的资源可以供内存中多个并发执行的进程共同使用</p><ol><li>互斥共享方式：临界资源（独占资源）</li><li>同时访问方式：磁盘，共享代码……</li></ol></li><li><p>虚拟：通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能</p><ol><li>时分复用：虚拟处理机（多道程序）技术</li><li>空分复用：多到程序共享内存</li></ol></li><li><p>异步</p><ol><li>在多道程序环境下，系统允许多个进程并发执行</li><li>由于对系统资源的竞争以及进程调度顺序不同，进程总是走走停停</li><li>进程以人们不可知的速度向前推进，这就是进程的异步性</li></ol></li></ol><h3 id="操作系统的主要功能" tabindex="-1"><a class="header-anchor" href="#操作系统的主要功能" aria-hidden="true">#</a> 操作系统的主要功能</h3><ol><li>处理机管理 <ol><li>主要任务：是对处理机进行分配并对其运行实施有效管理。对处理机的管理，可归结为对进程的管理。</li><li>功能 <ul><li>进程控制：创建、撤销以及进程状态转换。线程的管理</li><li>进程同步： <ul><li>进程互斥方式：是使诸进程以互斥方式访问临界资源。（互斥锁）</li><li>进程同步方式：对彼此相互合作去完成共同任务的诸进程，由同步机制对它们的执行次序加以协调。（信号量）</li></ul></li><li>进程通信：对于相互合作的进程，在它们运行时，相互之间往往要交换一定的信息，这种进程间所进行的信息交换称为进程通信</li><li>调度： <ul><li>作业调度：按一定算法从后备队列中选出若干个作业，为它们分配资源，建立进程，使之成为就绪进程，并把它们按一定算法插入就绪队列。</li><li>进程调度：按一定算法，如最高优先算法，从进程就绪队列中选出一进程，把处理机分配给它，为该进程设置运行现场，并使之投入运行。</li></ul></li></ul></li></ol></li><li>存储器管理 <ol><li>主要任务： <ol><li>为多道程序的并发运行提供良好环境。</li><li>便于用户使用存储器</li><li><strong>提高存储器的利用率</strong>。</li><li><strong>能从逻辑上来扩充内存</strong>。</li></ol></li><li>功能： <ol><li><strong>内存分配</strong>：多道程序能并发执行的首要条件是，各道程序都有自己的内存空间，因此，为每道程序分配内存空间是存储器管理的最基本功能。<strong>减少内存碎片</strong><ol><li>静态方式分配：程序编写是定义的内存</li><li>动态方式分配：运行时请求的内存</li></ol></li><li><strong>内存保护</strong>：为保证各道程序都能在自己的内存空间运行而互不干扰，要求每道程序在执行时能随时检查对内存的所有访问是否合法。 <ol><li>内存保护的手段： <ol><li>界限寄存器</li><li>越界中断</li></ol></li></ol></li><li><strong>地址映射</strong>：在多道程序的系统中，操作系统必须提供把程序地址空间中的逻辑地址转换为内存空间对应的物理地址的功能。</li><li><strong>内存扩充</strong>：由于物理内存的大小可能限制了大型作业或多个作业的并发执行，为了满足用户的要求并改善系统性能，必须对内存加以扩充。 <ol><li>用于实现： <ul><li>请求调入功能</li><li>置换功能</li></ul></li></ol></li></ol></li></ol></li><li>设备管理 <ol><li>主要任务： <ol><li>完成用户提出的 I/O 请求。</li><li>为用户分配 I/O 设备。</li><li>提高 CPU 和 I/O 设备的利用率。</li><li>提高 I/O 速度。</li><li>方便用户使用 I/O 设备</li></ol></li><li>具有以下功能： <ol><li>缓冲管理：基本任务是管理好各种类型的缓冲区。几乎所有的外围设备与处理机交换信息时，都要利用缓冲区来缓和 CPU 与 I/O 设备间速度不匹配的矛盾,提高 CPU 与 I/O 设备、设备与设备间操作的并行程度，以提高 CPU 和 I/O 设备的利用率。</li><li>设备分配：基本任务是根据用户的 I/O 请求和所采用的分配算法对设备进行分配，并将未获得所需设备的进程放进相应设备的等待队列。</li><li>设备处理：（驱动）基本任务是实现 CPU 和设备控制器之间的通信，即启动指定的 I/O 设备，完成用户规定的 I/O 操作，并对由设备发来的中断请求进行及时响应，根据中断类型进行相应的处理。</li></ol></li></ol></li><li>文件管理 <ol><li>主要功能： <ol><li>文件储存空间的管理</li><li>目录管理</li><li>文件的读/写管理和保护</li></ol></li></ol></li><li>用户接口 <ol><li>用户接口：便于用户直接或间接操作自己的作业 <ol><li>联机用户接口：便于用户通过指令对作业的控制</li><li>脱机用户接口：为批处理作业用户提供</li><li>图形用户接口：</li></ol></li><li>程序接口：为用户在执行程序中访问系统资源而设置，是用户程序取得操作系统服务的唯一途径</li></ol></li></ol><h2 id="第二章-进程的描述与控制" tabindex="-1"><a class="header-anchor" href="#第二章-进程的描述与控制" aria-hidden="true">#</a> 第二章 进程的描述与控制</h2><h3 id="_1-前趋图和程序执行" tabindex="-1"><a class="header-anchor" href="#_1-前趋图和程序执行" aria-hidden="true">#</a> 1 前趋图和程序执行</h3><h4 id="_1-1-前趋图" tabindex="-1"><a class="header-anchor" href="#_1-1-前趋图" aria-hidden="true">#</a> 1.1 前趋图</h4><ul><li>定义：指一个有向无循环图，可记为 DAG</li><li>进程（或程序）之间的前趋关系可用“ → ”来表示</li><li>每个节点还具有一个重量，用于表示该节点所含有的程序量或程序的执行时间。</li><li>前驱图中不允许循环。</li></ul><h4 id="_1-2-程序顺序执行" tabindex="-1"><a class="header-anchor" href="#_1-2-程序顺序执行" aria-hidden="true">#</a> 1.2 程序顺序执行</h4><ul><li>程序的顺序执行：一个应用程序由多个程序段组成，只有在前一个程序段执行完成后，才运行下一段程序</li><li>特征： <ol><li>顺序性：每一操作必须在下一操作开始之前结束</li><li>封闭性：程序运行时独占全机资源，其执行结果不受外界因素影响。</li><li>可再现性：只要程序执行时的环境和初始条件相同，都可以获得相同结果。</li></ol></li></ul><h4 id="_1-3-程序并发执行" tabindex="-1"><a class="header-anchor" href="#_1-3-程序并发执行" aria-hidden="true">#</a> 1.3 程序并发执行</h4><ul><li><p>程序的并发执行：</p><ul><li>提高资源利用率</li><li>只有不存在前趋关系的程序间才可能出现并发执行</li></ul></li><li><p>程序并发执行时的特征</p><ul><li>间断性：并发执行共享系统资源，形成制约关系导致间断性</li><li>失去封闭性：共享资源时，资源状态也会改变，使程序运行时会受到其他程序影响</li><li>不可再现性：程序执行时的环境和初始条件相同，但结果可能不相同</li></ul></li></ul><h3 id="_2-进程的描述" tabindex="-1"><a class="header-anchor" href="#_2-进程的描述" aria-hidden="true">#</a> 2 进程的描述</h3><h4 id="_2-1-进程的描述" tabindex="-1"><a class="header-anchor" href="#_2-1-进程的描述" aria-hidden="true">#</a> 2.1 进程的描述</h4><ul><li>进程控制块（PCB）：为了使参与并发执行的每个程序（含数据）都能独立的运行，在操作系统中必须为之配置一个专门的数据结构。称之为进程控制块。</li><li>进程的定义： <ol><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是具有独立功能的程序在一个数据集合上的运行的过程，它是系统 进行资源调度和分配的一个独立单位。</li><li><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong></li><li>进程 = PCB + 程序段 + 数据段</li></ol></li><li>进程的特征</li><li>动态性：进程有生命周期</li><li>并发性：多个进程实体同时存在与内存，一段时间可以同时执行</li><li>独立性：进程实体能独立运行，独立获得资源，独立调度的基本单位</li><li>异步性：按照异步方法运行</li><li>进程与程序的区别和联系：</li><li>进程：是程序的一次执行，是动态概念。一个进程可以同时包括多个程序； 进程是暂时的，是动态的产生和消亡的。</li><li>程序：是一组有序的静态指令，是静态概念。一个程序可以是多个进程的一部分；程序可以作为资料长期保存。</li></ul><h4 id="_2-2-进程的基本状态及转换" tabindex="-1"><a class="header-anchor" href="#_2-2-进程的基本状态及转换" aria-hidden="true">#</a> 2.2 进程的基本状态及转换</h4><ul><li><p>进程的三种基本状态</p><ul><li>就绪状态：这是指进程已处于准备好运行的状态，即进程已分配到处 CPU 以外的所有必要资源后，只要在获得 CPU，便可立即执行。<strong>就绪队列</strong></li><li>执行状态：指进程以获得 CPU，其程序正在执行的状态。</li><li>阻塞状态：这是指正在执行的进程由于发生某事件（如 I/O 请求、申请缓冲区失败等）暂时无法继续执行的状态，亦即进程执行受到阻塞。<strong>阻塞队列</strong></li></ul></li><li><p>三种基本状态的转换</p><p><img src="https://img-blog.csdnimg.cn/20210521150129546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>创建和终止状态</p><ul><li>创建状态 <ul><li>申请空白 PCB，填写控制和管理进程的信息</li><li>分配进程所需的资源，转入就绪态，插入就绪队列</li><li>资源不能完全满足，进入创建状态。创建未合成，不能调度</li><li>等资源满足后再转入就绪态</li></ul></li><li>终止状态： <ul><li>进程终止过程： <ul><li>等待 OS 进行善后处理</li><li>将 PCB 清零，并将 PCB 返还系统</li></ul></li><li>进程终止时机： <ul><li>进程执行到结束点</li><li>出现错误</li><li>被其他程序终结</li></ul></li></ul></li><li><img src="https://img-blog.csdnimg.cn/20210521150515110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h4 id="_2-3-挂起操作和进程状态的转换" tabindex="-1"><a class="header-anchor" href="#_2-3-挂起操作和进程状态的转换" aria-hidden="true">#</a> 2.3 挂起操作和进程状态的转换</h4><ul><li>挂起操作的引入： <ul><li>终端用户的需要</li><li>父进程请求</li><li>负荷调节的需要</li><li>操作系统的需要</li></ul></li><li>引入挂起原语操作后三个进程状态的转换 <ul><li><strong>活动就绪：处于未被挂起的就绪状态</strong></li><li><strong>精致就绪：活动就绪状态被挂起</strong></li><li><strong>活动阻塞：未被挂起的阻塞状态</strong></li><li><strong>静止阻塞：活动阻塞被挂起</strong></li><li>活动就绪 → 静止就绪</li><li>活动阻塞 → 静止阻塞</li><li>静止就绪 → 活动就绪</li><li>静止阻塞 → 活动阻塞</li></ul></li><li>引入挂起操作后五个进程状态的转换 <ul><li>NULL → 创建</li><li>创建 → 活动就绪</li><li>创建 → 静止就绪</li><li>执行 → 终止</li></ul></li><li><img src="https://img-blog.csdnimg.cn/20210521150928653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="img"></li></ul><h4 id="_2-4-进程管理中的数据结构" tabindex="-1"><a class="header-anchor" href="#_2-4-进程管理中的数据结构" aria-hidden="true">#</a> 2.4 进程管理中的数据结构</h4><ul><li>操作系统中用于管理控制的数据结构 <ul><li>系统为每个资源和每个进程都设置一个数据结构， 用于表征其实体，我么们称之为（资源信息表）或（进程信息表）</li><li>4 类数据结构：内存表、设备表、文件表、进程表</li></ul></li><li>进程控制块 PCB 的作用 <ul><li>作为独立运行基本单位的标志</li><li>能实现间断性的运行标志</li><li>提供进程管理所需要的信息</li><li>提供进程调度所需要的信息</li><li>实现与其他进程的同步与通信</li></ul></li><li>进程控制块的信息 <ul><li>进程标识符 <ul><li>外部标识符：方便用户对进程的访问</li><li>内部标识符：方便系统对进程的使用</li></ul></li><li>处理机状态：处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的 <ul><li>寄存器包括： <ul><li>通用寄存器</li><li>指令计数器</li><li>程序状态字<code>PSW</code></li><li>用户栈指针</li></ul></li></ul></li><li>进程调度信息 <ul><li>进程状态：指明进程的当前状态，它是作为进程调度和对换时的依据。</li><li>进程优先级：是用于描述进程使用处理机的优先级别的一个整数。</li><li>进程调度所需要的其他信息，它们与所采用的进程调度算法有关。</li><li>事件：是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因</li></ul></li><li>进程控制信息 <ul><li>程序和数据的地址，进程实体中的程序和数据的内存或外存地址， 以便在调度到改进程时，能从 PCB 中找到其程序和数据。</li><li>进程同步和通信机制，这是实现进程同步和进程通信时必需的机制。</li><li>资源清单：在该清单中列出了进程在运行期间所需要的全部资源，另外 还有一张已分配到该进程的资源的清单。</li></ul></li></ul></li><li>进程控制块的组织方式 <ul><li>链接指针</li><li>线性方式</li><li>链接方式</li><li>索引方式</li></ul></li></ul><h3 id="_3-进程控制" tabindex="-1"><a class="header-anchor" href="#_3-进程控制" aria-hidden="true">#</a> 3 进程控制</h3><h4 id="_3-1-操作系统内核" tabindex="-1"><a class="header-anchor" href="#_3-1-操作系统内核" aria-hidden="true">#</a> 3.1 操作系统内核</h4><ul><li><p>通常将处理机的执行状态分为系统状态和用户状态两种</p><ul><li>系统态：又称为管态，也称为内核态。</li><li>用户态：又称为目态。</li><li>保护软件，防止受到其他应用的破坏，提高 OS 运行效率</li></ul></li><li><p>大多数操作系统内核包括两大方面的内容：</p><ul><li>支撑功能 <ul><li>中断处理：系统调用、键盘输入</li><li>时钟管理：时间片、时钟中断</li><li>原语操作：链表操作</li></ul></li><li>资源管理功能 <ul><li>进程管理：调度、同步、通信</li><li>存储器管理：地址转换、分配</li><li>设备管理：driver&amp;buffer、分配</li></ul></li></ul></li></ul><h4 id="_3-2-进程的创建" tabindex="-1"><a class="header-anchor" href="#_3-2-进程的创建" aria-hidden="true">#</a> 3.2 进程的创建</h4><ul><li>进程的层次结构 <ul><li>通常，把创建进程的进程成为--父进程；把被创建进程的进程成为子进程。</li><li>在 UNIX 中，进程与其子孙进程共同组成一个进程家族（组）。</li><li>但在 Windows 中不存在任何进程层次结构的概念。</li></ul></li><li>进程图：描述进程关系的有向图</li><li>引起创建进程的事件 <ul><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ul></li><li>进程的创建(create) <ul><li>申请空白 PCB 为新进程申请获得唯一的数字表示符，并从 PCB 集合中索取一个空白 PCB。</li><li>为新进程分配其运行所需的资源。</li><li>初始化进程控制块</li><li>如果程序就绪队列能够接纳新进程，便将新进程插入就绪队列。</li></ul></li></ul><h4 id="_3-3-进程的终止" tabindex="-1"><a class="header-anchor" href="#_3-3-进程的终止" aria-hidden="true">#</a> 3.3 进程的终止</h4><ul><li>引起进程终止的事件 <ul><li>正常结束</li><li>异常结束 <ul><li>越界错：这是指程序所访问的存储区，已越出该程序的区域</li><li>保护错：指进程试图去访问一个不允许访问的资源或文件。或者以不适当的方式进行访问。</li><li>非法指令：指程序试图去执行一个不存在的指令。</li><li>特权指令错：指用户进程试图去执行一条只允许 OS 执行的指令。</li><li>运行超时：指进程的执行时间超过了指定的最大值。</li><li>等待超时：指进程等待某事件的时间超过了规定的最大值</li><li>算术运算错：指进程试图去执行一个被禁止的运算。</li></ul></li><li>外界干预： <ul><li>进程应外界请而终止，如死锁等</li></ul></li></ul></li><li>进程终止的过程：(terminate) <ul><li>根据被终止进程的标识符，从 PCB 集合中 j 检索出该进程的 PCB，从中读出该进程的状态</li><li>若进程为执行状态，则终止进程执行并置调度标志为真</li><li>有子孙进程也终止</li><li>将所有资源归还给父进程或者系统</li><li>将被终止的进程（PCB）从所在的队列（或链表）中移除，等待其它程序来搜集信息</li></ul></li></ul><h4 id="_3-4-进程的阻塞与唤醒" tabindex="-1"><a class="header-anchor" href="#_3-4-进程的阻塞与唤醒" aria-hidden="true">#</a> 3.4 进程的阻塞与唤醒</h4><ul><li>引起进程阻塞和唤醒的事件 <ul><li>向系统请求共享资源失败</li><li>等待某种操作的完成</li><li>新数据尚未到达</li><li>等待新任务的到达</li><li><strong>等待资源可用、IO 操作完成、数据准备好、任务到达则唤醒进程</strong></li></ul></li><li>进程阻塞的过程（block） <ul><li>进程通过调用阻塞原语<code>block</code>将自己阻塞</li><li>阻塞是进程自身的主动行为</li><li>过程： <ul><li>立即停止执行，把 PCB 状态有执行改为阻塞</li><li>将 PCB 插入到阻塞队列</li><li>转调度程序重新调度，将处理机分配给另一就绪进程</li></ul></li></ul></li><li>进程唤醒的过程：（wakeup） <ul><li>把阻塞的进程从等待该事件的阻塞队列中移出</li><li>PCB 中的现行状态由阻塞改为就绪</li><li>将 PCB 插入到就绪队列</li></ul></li></ul><h4 id="_3-5-进程的挂起与激活" tabindex="-1"><a class="header-anchor" href="#_3-5-进程的挂起与激活" aria-hidden="true">#</a> 3.5 进程的挂起与激活</h4><ul><li>进程的挂起过程(suspend) <ul><li>检查进程状态</li><li>活动就绪—&gt;静止就绪；活动阻塞—&gt;静止阻塞</li><li>将 PCB 复制到指定内存区域方便解析</li><li>若挂起进程正在执行，则重新调度</li></ul></li><li>进程的激活过程（active） <ul><li>将进程由外存调入内存</li><li>检查进程状态；静止就绪—&gt;活动就绪；静止阻塞—&gt;活动阻塞</li><li>若采用抢占式调度策略且为活动就绪，则评估是否要重新调用</li></ul></li></ul><h3 id="_4-进程同步" tabindex="-1"><a class="header-anchor" href="#_4-进程同步" aria-hidden="true">#</a> 4 进程同步</h3><h4 id="_4-1-进程同步基本概念" tabindex="-1"><a class="header-anchor" href="#_4-1-进程同步基本概念" aria-hidden="true">#</a> 4.1 进程同步基本概念</h4><ul><li><p>两种形式的制约关系</p><ul><li>间接相互制约关系 临界资源 互斥</li><li>直接相互制约关系 合作 同步</li></ul></li><li><p>临界资源：多个进程应采用互斥方式实现共享访问的资源</p></li><li><p>临界区：把每个进程中访问临界资源的那段代码成为临界区（cs）</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>while（TRUE）{
		进入区
		临界区
		退出区
		剩余区
	}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>同步机制应遵循的规则</p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul></li></ul><h4 id="_4-2-硬件同步机制" tabindex="-1"><a class="header-anchor" href="#_4-2-硬件同步机制" aria-hidden="true">#</a> 4.2 硬件同步机制</h4><ul><li><p>关中断</p><ul><li>缺点：滥用关中断权力会导致严重后果</li></ul></li><li><p>利用 Test-And-Set 指令实现互斥</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>Boolean <span class="token function">TS</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
	boolean old<span class="token punctuation">;</span>
	old<span class="token operator">=</span><span class="token operator">*</span>lock<span class="token punctuation">;</span>
	<span class="token operator">*</span>lock<span class="token operator">=</span>true<span class="token punctuation">;</span>
	<span class="token keyword">return</span> old<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 期间不会响应中断</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>实现：为每一个临界资源设置一个布尔变量 lock，初始值为 false</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">do</span><span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">while</span> <span class="token function">TS</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	临界区<span class="token punctuation">;</span>
	lock<span class="token operator">=</span>False<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>利用 Swap 指令实现进程互斥</p><ul><li>为每一个临界资源设置一个布尔变量 lock，初始值为 false</li></ul><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>a<span class="token punctuation">,</span>boolean <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>
	boolean temp<span class="token punctuation">;</span>
	temp<span class="token operator">=</span><span class="token operator">*</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>a<span class="token operator">=</span><span class="token operator">*</span>b<span class="token punctuation">;</span>
	<span class="token operator">*</span>b<span class="token operator">=</span>temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">do</span><span class="token punctuation">{</span>
	key<span class="token operator">=</span>true<span class="token punctuation">;</span>
	<span class="token keyword">do</span><span class="token punctuation">{</span>
		<span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>key<span class="token operator">!</span>false<span class="token punctuation">)</span>
	临界区
	lock<span class="token operator">=</span>false
<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_4-3-信号量机制" tabindex="-1"><a class="header-anchor" href="#_4-3-信号量机制" aria-hidden="true">#</a> 4.3 信号量机制</h4><ul><li><p>整形信号量</p><ul><li><p>整形信号量定义为表示资源数目的整形量 S</p></li><li><p>除了初始化外，只能通过原子操作 wait(S)和 signal(S)进行操作</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// P操作</span>
<span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等待</span>
	S<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// V操作</span>
<span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">{</span>
S<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>执行时不允许中断</li></ul></li></ul></li><li><p>记录型信号量</p><ul><li><p>不存在忙等现象</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token comment">//资源数量</span>
    <span class="token keyword">struct</span> <span class="token class-name">PCB</span> <span class="token operator">*</span> list<span class="token punctuation">;</span> <span class="token comment">// 等待丢列</span>
<span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token function">wait</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token comment">// P(S) 申请</span>
<span class="token punctuation">{</span>
    S<span class="token operator">-&gt;</span>value<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 资源数目</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自我阻塞</span>
<span class="token punctuation">}</span>

<span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token comment">// V(S) 释放资源</span>
<span class="token punctuation">{</span>
    S<span class="token operator">-&gt;</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒队首</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>AND 型信号量</p><ul><li>前两种只适合共享一个临界资源，多个临界资源可能会死锁</li></ul></li><li><p>信号量集</p></li></ul><h4 id="_4-4-信号量的应用-一次对多个资源申请" tabindex="-1"><a class="header-anchor" href="#_4-4-信号量的应用-一次对多个资源申请" aria-hidden="true">#</a> 4.4 信号量的应用（一次对多个资源申请）</h4><ul><li>利用信号量实现进程互斥 <ul><li>分析并发进程的关键活动，划定临界区</li><li>设置互斥信号量<code>mutex</code>，初值为 1</li><li>在临界区之前执行<code>P(mutex)</code></li><li>在临界区之后执行<code>V(mutex)</code></li></ul></li><li>利用信号量实现前趋关系 <ul><li>要为每一对前驱关系各设置一个同步变量</li><li>在“前操作”之后对相应的同步变量执行 V 操作</li><li>在“后操作”之前对相应的同步变量执行 Р 操作</li></ul></li></ul><h4 id="_4-5-管程机制" tabindex="-1"><a class="header-anchor" href="#_4-5-管程机制" aria-hidden="true">#</a> 4.5 管程机制</h4><ul><li>管程的定义:代表共享资源的数据结构以及由对该共享数据结构实时操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，我们称之为管程。</li><li>管程包括： <ul><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组进程</li><li>对局部于管程的共享数据结构设置初始值的语句</li></ul></li><li>条件变量</li></ul><h3 id="_5-经典进程的同步问题" tabindex="-1"><a class="header-anchor" href="#_5-经典进程的同步问题" aria-hidden="true">#</a> 5 经典进程的同步问题</h3><h4 id="_5-1-生产者-消费者问题-互斥、同步" tabindex="-1"><a class="header-anchor" href="#_5-1-生产者-消费者问题-互斥、同步" aria-hidden="true">#</a> 5.1 生产者-消费者问题 (互斥、同步)</h4><ul><li><p>利用记录型信号量解决生产者-消费者问题</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> in<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>out<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
item buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 缓冲区</span>
semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 互斥信号量</span>
semaphore empty<span class="token operator">=</span>n<span class="token punctuation">,</span>full<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 资源信号量 生产者区 消费者缓冲区</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  cobegin
    <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  coend
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">do</span><span class="token punctuation">{</span> producer an item in nextp<span class="token punctuation">;</span>
		<span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//生产者申请一个空缓冲区（即申请访问临界资源）</span>
     <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//进程进入临界区，加锁，使其他进程无法访问该临界资源</span>
   	<span class="token function">buffer</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token operator">=</span> nextp<span class="token punctuation">;</span>   <span class="token comment">//把消息存入缓冲区（访问临界资源）</span>
    in <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">(</span>in <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>    <span class="token comment">//存入地址指向下一个缓冲区</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//退出临界区，开锁</span>
  	<span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//释放一个满缓冲区</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">do</span><span class="token punctuation">{</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>       			<span class="token comment">//消费者申请一个满缓冲区（即申请访问临界资源）</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//进入临界区，加锁</span>
        nextc <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">buffer</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//取出缓冲区中消息（访问临界资源）</span>
        out <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> mod n<span class="token punctuation">;</span>  <span class="token comment">//取出地址指向下一个缓冲区</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//退出临界区， 开锁</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//释放空缓冲区</span>
        consumer the item in nextc<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>、
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>利用 AND 信号量解决生产者-消费者问题</p><ul><li>一次申请所有的资源</li></ul></li><li><p>利用管程解决生产者-消费者问题</p></li></ul><h4 id="_5-2-哲学家进餐问题-互斥" tabindex="-1"><a class="header-anchor" href="#_5-2-哲学家进餐问题-互斥" aria-hidden="true">#</a> 5.2 哲学家进餐问题 （互斥）</h4><ul><li><p>利用记录型信号量解决哲学家进餐问题</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>	<span class="token keyword">int</span> chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 第i个人进餐</span>
	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		<span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左边的筷子</span>
		<span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右边</span>
		eat<span class="token punctuation">;</span>
		<span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		think<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>最多允许 4 个人同时拿左筷子</li><li>仅当左右筷子都可用才就餐</li><li>奇数先拿左筷子，偶数拿右筷子</li></ul></li><li><p>利用 AND 信号量解决哲学家进餐问题</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		think<span class="token punctuation">;</span>
		<span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>mod <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同时申请两个筷子</span>
		eat<span class="token punctuation">;</span>
		<span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>mod <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放两个资源</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token comment">// 无死锁</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_5-3-读者-写者问题-有条件的互斥" tabindex="-1"><a class="header-anchor" href="#_5-3-读者-写者问题-有条件的互斥" aria-hidden="true">#</a> 5.3 读者-写者问题 （有条件的互斥）</h4><ul><li>利用记录型信号量解决读者-写者问题</li><li>利用信号量集机制解决读者-写者问题</li></ul><h3 id="_6-进程通信" tabindex="-1"><a class="header-anchor" href="#_6-进程通信" aria-hidden="true">#</a> 6 进程通信</h3><ul><li>进程之间的信息交换型</li></ul><h4 id="_6-1-进程通信的类型" tabindex="-1"><a class="header-anchor" href="#_6-1-进程通信的类型" aria-hidden="true">#</a> 6.1 进程通信的类型</h4><ul><li>共享存储器系统 <ul><li>基于共享数据结构的通信方式。效率低</li><li>基于共享存储区的通信方式。</li></ul></li><li>管道通信系统 <ul><li>指用于连接一个读进程和一个写进程以实现他们之间的通信的一个共享文件，又名 pipe 文件。</li><li>管道机制必须提供三种协调机制 ： <ul><li>互斥</li><li>同步</li><li>确定对方是否存在，只有确定对方已存在时才能进行通信。</li></ul></li></ul></li><li>消息传递系统：属于高级通信方式，通过<code>send/receive</code>原语实现数据交换 <ul><li>直接通信方式：直接发送给对方</li><li>间接通信方式：通过中间体完成</li></ul></li><li>客户机---服务器系统：用于网络通信 <ul><li>套接字（<code>scoket</code>) <ul><li>一个套接字就是一个通信标识类型的数据结构</li></ul></li><li>远程过程调用（<code>RPC</code>） <ul><li>是一个通信协议 <ul><li>允许本地主机调用远程主机</li></ul></li></ul></li><li>远程方法调用(<code>RMC</code>)</li></ul></li></ul><h4 id="_6-2-消息传递通信的实现方式" tabindex="-1"><a class="header-anchor" href="#_6-2-消息传递通信的实现方式" aria-hidden="true">#</a> 6.2 消息传递通信的实现方式</h4><ul><li>直接消息传递系统 <ul><li>对称寻址方式 <ul><li>send（receiver，message） 发送一个消息给接收进程</li><li>receive（sender，message） 接收 Sender 发来的消息</li></ul></li><li>非对称寻址方式 <ul><li>send（P，message） 发送一个消息给进程 P。</li><li>receive（id，message） 接收来自任何进程的消息，id 变量可设置为进行通信的发送方进程的 id 或名字。</li></ul></li></ul></li><li>信箱通信：属于间接通信方式，可以单向也可以双向 <ul><li>信箱的结构 <ul><li>信箱头</li><li>信箱体</li></ul></li><li>信箱通信原语 <ul><li>邮箱的创建和撤销</li><li>发送<code>send()</code></li><li>接受<code>rescive()</code></li></ul></li><li>信箱的类型 <ul><li>私有信箱：用户创建，单向，读取信息，进程完成消失</li><li>共有信箱：OS 创建，双向</li><li>共享信箱：用户创建，指定共享者，党项读取</li></ul></li></ul></li></ul><h4 id="_6-3-直接消息传递系统实例" tabindex="-1"><a class="header-anchor" href="#_6-3-直接消息传递系统实例" aria-hidden="true">#</a> 6.3 直接消息传递系统实例</h4><ul><li><p>消息缓冲队列通信中的数据结构</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">message_buffer</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> sender<span class="token punctuation">;</span> <span class="token comment">// 发送者进程标识符</span>
	<span class="token keyword">int</span> size<span class="token punctuation">;</span>   <span class="token comment">// 消息长度</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>text<span class="token punctuation">;</span> <span class="token comment">// 消息内容</span>
	<span class="token keyword">struct</span> <span class="token class-name">message_buffer</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>PCB 中增加消息队列首指针，互斥信号量。资源数信号量</li></ul></li><li><p>发送原语</p></li><li><p>接受原语</p></li></ul><h3 id="_7-线程的基本概念" tabindex="-1"><a class="header-anchor" href="#_7-线程的基本概念" aria-hidden="true">#</a> 7 线程的基本概念</h3><h4 id="_7-1-线程的引入" tabindex="-1"><a class="header-anchor" href="#_7-1-线程的引入" aria-hidden="true">#</a> 7.1 线程的引入</h4><ul><li>进程的两个基本属性 <ul><li>进程是一个可拥有资源的独立单位。</li><li>进程同时又是一个可独立调度和分派的基本单位。</li></ul></li><li>程序并发执行所需要付出的时空开销 <ul><li>创建进程</li><li>撤销进程</li><li>进程切换</li></ul></li><li>线程—作为调度和分派的基本单位</li></ul><h4 id="_7-2-线程与线程的比较" tabindex="-1"><a class="header-anchor" href="#_7-2-线程与线程的比较" aria-hidden="true">#</a> 7.2 线程与线程的比较</h4><ul><li>调度的基本单位：进程调度与线程调度</li><li>并发行：线程比进程并发性好</li><li>拥有资源：线程只有少量的资源</li><li>独立性：线程独立性比进程低得多</li><li>系统开销：线程开销小</li><li>支持多处理系统：更适合多处理机</li></ul><h4 id="_7-3-线程的状态和线程控制块" tabindex="-1"><a class="header-anchor" href="#_7-3-线程的状态和线程控制块" aria-hidden="true">#</a> 7.3 线程的状态和线程控制块</h4><ul><li>线程运行的三个状态 <ul><li>执行状态</li><li>就绪状态</li><li>阻塞状态</li></ul></li><li>线程控制块 TCB <ul><li>线程控制标识符</li><li>一组寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区</li><li>信号屏蔽</li><li>堆栈指针</li></ul></li><li>多线程 OS 中的进程属性 <ul><li>进程是一个可拥有资源的基本单位。</li><li>多个线程可并发执行。</li><li>进程已不是可执行的实体。</li></ul></li></ul><h3 id="_8-线程的实现" tabindex="-1"><a class="header-anchor" href="#_8-线程的实现" aria-hidden="true">#</a> 8 线程的实现</h3><h4 id="_8-1-线程的实现方式" tabindex="-1"><a class="header-anchor" href="#_8-1-线程的实现方式" aria-hidden="true">#</a> 8.1 线程的实现方式</h4><ul><li>内核支持线程 KST <ul><li>内核支持线程同进程一样都是在内核支持下运行的</li><li>创建, 阻塞, 撤销, 切换都是在内核空间实现的</li><li>内核空间中为每一个线程设置了一个线程控制块, 内核通过线程控制块对其进行控制</li><li>优点： <ul><li>在多处理器系统中内核可以同时调度同一进程中的多个线程并发执行</li><li>如果进程中的一个线程阻塞了, 内核可继续调度该进程中的其他线程</li></ul></li><li>缺点： <ul><li>同一进程中切换线程开销较大, 因为要经历用户态, 内核态的切换</li></ul></li></ul></li><li>用户级线程 ULT <ul><li>用户级线程与内核无关</li><li>创建, 撤销, 同步和通信等功能都是在用户空间中实现的.</li><li>调度以进程为单位</li><li>优点： <ul><li>线程切换不需要转换内核状态, 节省了切换的开销</li><li>不同的进程可根据自身选择不同的调度算法</li><li>用户级线程的实现与 OS 平台无关</li></ul></li><li>缺点： <ul><li>当一个线程阻塞时, 其他所有的线程都被阻塞</li><li>不能利用多处理机的优点</li></ul></li></ul></li><li>组合方式 <ul><li>多对一模型 <ul><li>将用户线程映射到一个内核控制线程, 当用户线程需要访问内核时, 将其映射到一个内核线程, 但每次只允许一个线程进行映射.主要的优点是开销小, 效率高, 缺点在于一个线程在访问内核时发生阻塞, 则整个进程都会被阻塞. 且同一时刻只有一个线程可以访问内核</li></ul></li><li>一对一模型 <ul><li>每一个用户级线程都映射到一个内核控制线程. 主要的优点是当一个线程阻塞, 允许其他线程继续运行. 且允许多个线程并行地运行在多处理机系统上. 缺点是开销较大</li></ul></li><li>多对多模型 <ul><li>将多个用户线程映射到同样数量或者更少数量的内核线程上,可以根据实际情况调整内核控制线程数目, 结合了上述两种模型的优点.</li></ul></li></ul></li></ul><h4 id="_8-2-线程的终止和创建" tabindex="-1"><a class="header-anchor" href="#_8-2-线程的终止和创建" aria-hidden="true">#</a> 8.2 线程的终止和创建</h4><ul><li>线程的创建</li><li>线程的终止</li></ul><h2 id="第三章-处理机调度与死锁" tabindex="-1"><a class="header-anchor" href="#第三章-处理机调度与死锁" aria-hidden="true">#</a> 第三章 处理机调度与死锁</h2><h3 id="_1-处理机调度的层次和调度算法的目标" tabindex="-1"><a class="header-anchor" href="#_1-处理机调度的层次和调度算法的目标" aria-hidden="true">#</a> 1 处理机调度的层次和调度算法的目标</h3><h4 id="_1-1-处理机调度的层次" tabindex="-1"><a class="header-anchor" href="#_1-1-处理机调度的层次" aria-hidden="true">#</a> 1.1 处理机调度的层次</h4><ul><li>高级调度：作业调度，它的调度对象是作业 <ul><li>功能：根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为他们创建进程、分配必要的资源，并将它们放入就绪队列。</li><li>主要用于多批道处理系统中</li></ul></li><li>初级调度：进程调度或短程调度，其所调度的对象是进程 <ul><li>功能：根据某种算法，决定就绪队列中哪个进程应获得处理机，并由分派程序将处理机分配给选中的进程。</li><li>在多道批处理、分时和实时三种类型的 OS 中，都必须配置这级调度。</li></ul></li><li>中级调度：内存调度，内存管理的对换功能 <ul><li>目的：提高内存利用率和系统吞吐量</li></ul></li></ul><h4 id="_1-2-处理机调度算法的目标" tabindex="-1"><a class="header-anchor" href="#_1-2-处理机调度算法的目标" aria-hidden="true">#</a> 1.2 处理机调度算法的目标</h4><ul><li><p>处理机调度算法的共同目标</p><ul><li><p>资源利用率:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>										CPU有效工作时间
CPU的利用率 = ————————————————————————————————————
							CPU有效工作时间 + CPU空闲等待时间

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>公平性</p></li><li><p>平衡性</p></li><li><p>策略强制执行</p></li></ul></li><li><p>批处理系统的目标</p><ul><li>平均周转时间短。----所谓周转时间是指从作业被提交给系统开始，到作业完成为止这段时间间隔。 <ul><li>作业在外存后备队列上等待（作业）调度的时间。</li><li>进程在就绪队列上等待进程调度的时间。</li><li>进程在 CPU 上执行的时间。</li><li>进程等待 I/O 操作完成的时间。</li></ul></li><li>系统吞吐量高</li><li>处理机利用率高</li></ul></li><li><p>分时系统的目标</p><ul><li>响应时间快</li><li>均衡性</li></ul></li><li><p>实时系统的目标</p><ul><li>截止时间的保证</li><li>可预测性</li></ul></li></ul><h3 id="_2-作业与作业调度" tabindex="-1"><a class="header-anchor" href="#_2-作业与作业调度" aria-hidden="true">#</a> 2 作业与作业调度</h3><h4 id="_2-1-批处理系统中的作业" tabindex="-1"><a class="header-anchor" href="#_2-1-批处理系统中的作业" aria-hidden="true">#</a> 2.1 批处理系统中的作业</h4><ul><li>作业和作业步 <ul><li>作业：程序、数据、作业说明书</li><li>作业步：对作业进行处理的相对应的一个步骤</li></ul></li><li>作业控制块（JCB） <ul><li>为没哟个作业设置作业控制块 JCB，是作业存在的标识</li><li>作业进入系统时有作业注册程序创建 JCB</li></ul></li><li>作业运行的三个阶段和三种状态 <ul><li>收容阶段 — “后备状态” 创建 JCB，放入后备队列</li><li>运行阶段 — “运行状态” 进入就绪队列到运行结束前</li><li>完成阶段 — “完成状态”作业完成或者发生异常</li></ul></li></ul><h4 id="_2-2-作业调度的主要任务" tabindex="-1"><a class="header-anchor" href="#_2-2-作业调度的主要任务" aria-hidden="true">#</a> 2.2 作业调度的主要任务</h4><ul><li>接纳多少个作业</li><li>接纳哪些作业：取决于调度算法</li></ul><h4 id="_2-3-先来先服务算法和短作业优先调度算法" tabindex="-1"><a class="header-anchor" href="#_2-3-先来先服务算法和短作业优先调度算法" aria-hidden="true">#</a> 2.3 先来先服务算法和短作业优先调度算法</h4><ul><li><p>先来先服务算法</p><p><img src="/assets/image-20220515140006143.d9ab16e4.png" alt="image-20220515140006143"></p><p><img src="/assets/image-20220515140038090.95e4e409.png" alt="image-20220515140038090"></p></li><li><p>短作业优先调度算法</p><ul><li><p>缺点：</p><ul><li>必须预知作业运行时间</li><li>对于长作业不利</li><li>不法实现人机交互</li><li>不考虑作业紧迫性</li></ul></li><li><p>非抢占式</p><p><img src="https://img-blog.csdnimg.cn/e85f800a420547e5b153537603adeaed.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>抢占式</p><p><img src="https://img-blog.csdnimg.cn/e7d19a1ccb2c41518644f35e5760362d.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/0865b32bd4a04ca4af1e22093721b61d.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/45b894f896b7422a868cb48e79b4c8a0.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="_2-4-优先级调度算法和高响应比优先调度算法" tabindex="-1"><a class="header-anchor" href="#_2-4-优先级调度算法和高响应比优先调度算法" aria-hidden="true">#</a> 2.4 优先级调度算法和高响应比优先调度算法</h4><ul><li><p>优先级调度算法</p></li><li><p>高响应比优先调度算法（非抢占式）</p><p><img src="https://img-blog.csdnimg.cn/1f121d843d9b4a6fa239a11b1d3de562.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/37d9c5e63f2748b88e5d770ce205585f.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/1943b35186624b8a819e5ba79d8803c8.png#pic_center" alt="在这里插入图片描述"></p></li></ul><h3 id="_3-进程调度" tabindex="-1"><a class="header-anchor" href="#_3-进程调度" aria-hidden="true">#</a> 3 进程调度</h3><h4 id="_3-1-进程调度的任务、机制和方式" tabindex="-1"><a class="header-anchor" href="#_3-1-进程调度的任务、机制和方式" aria-hidden="true">#</a> 3.1 进程调度的任务、机制和方式</h4><ul><li>进程调度的任务 <ul><li>保存处理机的现场信息</li><li>按某种算法选取进程</li><li>把处理机分配给进程。</li></ul></li><li>进程调度机制 <ul><li>排队器：把就绪队列构成一个或多个队列</li><li>分派器</li><li>上下文切换器</li></ul></li><li>进程调度方式 <ul><li>非抢占方式 <ul><li>引起因素： <ul><li>进程执行完毕，或者是无法继续运行</li><li>进行中的进程提出 I/O 请求暂停执行</li><li>执行原语操作</li></ul></li><li>特点： <ul><li>简单。开销小、适合批处理，不能用于实时和分时</li></ul></li></ul></li><li>抢占方式 <ul><li>复杂。开销大</li><li>原则： <ul><li>优先权原则</li><li>短进程优先原则</li><li>时间片原则</li></ul></li></ul></li></ul></li></ul><h4 id="_3-2-轮转调度算法" tabindex="-1"><a class="header-anchor" href="#_3-2-轮转调度算法" aria-hidden="true">#</a> 3.2 轮转调度算法</h4><ul><li><p>论转法的基本原理</p><ul><li>分时系统中常采用</li><li>轮流让就绪队列的进程依次执行一个时间片</li></ul></li><li><p>进程切换时机</p><ul><li>进程完成</li><li>时间片完成</li><li>IO 请求</li></ul></li><li><p>时间片大小的确定</p><ul><li>以略大于一次典型交互时间为定</li><li>时间片为 2</li></ul><p><img src="https://img-blog.csdnimg.cn/ca6e65086f804ea0b420e6d2b05c8511.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e170b43c59b842bbb04e1f2c8c5c7b08.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/15a43000e9964c18bee02d1b8f3e6dca.png#pic_center" alt="在这里插入图片描述"></p></li></ul><h4 id="_3-3-优先级调度算法" tabindex="-1"><a class="header-anchor" href="#_3-3-优先级调度算法" aria-hidden="true">#</a> 3.3 优先级调度算法</h4><ul><li><p>优先级调度算法的类型</p><ul><li><p>非抢占式优先级调度算法</p><p><img src="https://img-blog.csdnimg.cn/2f5b2e97283f449dbcd04bc1bc20a976.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>抢占式优先级调度算法</p><p><img src="https://img-blog.csdnimg.cn/bf81e4c5ae4b4cd493853ba1917dca3a.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li><li><p>优先级的类型</p><ul><li>静态优先级 ：创建进程时确定，之后一直不变。 <ul><li>依据： <ul><li>进程类型：系统进程&gt;用户进程</li><li>进程对资源的需求：需求少优先级高</li><li>用户要求：根据紧迫程度决定</li></ul></li></ul></li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级</li></ul></li></ul><h4 id="_3-4-多队列调度算法" tabindex="-1"><a class="header-anchor" href="#_3-4-多队列调度算法" aria-hidden="true">#</a> 3.4 多队列调度算法</h4><ul><li>针对不同的用户进程提供多种调度策略</li></ul><h4 id="_3-5-多级反馈队列调度算法" tabindex="-1"><a class="header-anchor" href="#_3-5-多级反馈队列调度算法" aria-hidden="true">#</a> 3.5 多级反馈队列调度算法</h4><p><img src="https://img-blog.csdnimg.cn/974345f9476a430ab328189f530ddae0.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e7e13f2477a348a6b8233a4321d75e37.png#pic_center" alt="在这里插入图片描述"></p><ul><li>调度机制 <ul><li>设置多个就绪队列</li><li>每个队列都采用 FCFS 算法，最后队列采用 RR</li><li>按队列优先级调度</li></ul></li><li>调度算法的性能 <ul><li>终端行用户</li><li>短批处理作业用户</li><li>长批处理作业用户</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/92ebc7a2611c49a8a58601b6d1a402a4.png#pic_center" alt="在这里插入图片描述"></p><h4 id="_3-6-基于公平原则的调度算法-强调公平性" tabindex="-1"><a class="header-anchor" href="#_3-6-基于公平原则的调度算法-强调公平性" aria-hidden="true">#</a> 3.6 基于公平原则的调度算法 强调公平性</h4><ul><li>保证调度算法：保证进程分配处理机的公平性</li><li>公平分享调度算法：保证用户分配处理机的公平性</li></ul><h3 id="_4-实时调度" tabindex="-1"><a class="header-anchor" href="#_4-实时调度" aria-hidden="true">#</a> 4 实时调度</h3><h4 id="_4-1-实现实时调度的基本条件" tabindex="-1"><a class="header-anchor" href="#_4-1-实现实时调度的基本条件" aria-hidden="true">#</a> 4.1 实现实时调度的基本条件</h4><ul><li>提供必要的信息 <ul><li>就绪时间</li><li>开始截止时间和完成截止时间。</li><li>处理时间</li><li>资源要求</li><li>优先级</li></ul></li><li>系统处理能力强</li><li>采用抢占式调度机制</li><li>具有快速切换机制</li></ul><h4 id="_4-2-实时调度算法分类" tabindex="-1"><a class="header-anchor" href="#_4-2-实时调度算法分类" aria-hidden="true">#</a> 4.2 实时调度算法分类</h4><ul><li>非抢占式调度算法分类 <ul><li>非抢占式轮转调度算法 新任务放在队尾</li><li>非抢占式优先调度算法 新任务根据优先权放在相应的位置</li></ul></li><li>抢占式调度算法 <ul><li>基于时钟中断的抢占式优先级调度算法 只有时钟中断才抢占</li><li>立即抢占的优先级调度算法 立即抢占</li></ul></li></ul><h4 id="_4-3-最早截止时间优先算法" tabindex="-1"><a class="header-anchor" href="#_4-3-最早截止时间优先算法" aria-hidden="true">#</a> 4.3 最早截止时间优先算法</h4><ul><li><p>根据任务截止时间确定优先级，越早越高</p></li><li><p>最早截止时间任务排在队首</p></li><li><p>非抢占式调度方式用于非周期实时任务</p></li><li><p>抢占式调度方式 y 用于周期实时任务</p></li></ul><h4 id="_4-4-最低松弛度优先-llf-算法" tabindex="-1"><a class="header-anchor" href="#_4-4-最低松弛度优先-llf-算法" aria-hidden="true">#</a> 4.4 最低松弛度优先 LLF 算法</h4><ul><li>根据任务紧急程度（松弛度）确定优先级</li><li>紧急任务松弛度小</li><li>用于抢占式调度</li><li>任务最迟开始时间=任务必须完成时间-运行时间</li><li>松弛度=必须完成的时间-运行时间-当前时间</li></ul><h4 id="_4-5-优先级倒置-高优先级进程被低优先级进程阻塞" tabindex="-1"><a class="header-anchor" href="#_4-5-优先级倒置-高优先级进程被低优先级进程阻塞" aria-hidden="true">#</a> 4.5 优先级倒置：高优先级进程被低优先级进程阻塞</h4><ul><li>优先级倒置的形成 <ul><li>共享临界资源</li></ul></li><li>优先级倒置的解决办法 <ul><li>进入临界区的进程不能被抢占，适用于临界区较短的情况</li><li>允许动态优先级继承，RTOS 必须使用</li></ul></li></ul><h3 id="_5-死锁概述" tabindex="-1"><a class="header-anchor" href="#_5-死锁概述" aria-hidden="true">#</a> 5 死锁概述</h3><h4 id="_5-1-资源问题" tabindex="-1"><a class="header-anchor" href="#_5-1-资源问题" aria-hidden="true">#</a> 5.1 资源问题</h4><ul><li>可重用性资源和消耗性资源 <ul><li>可重用性资源： <ul><li>每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享</li><li>进程在使用可重用性资源时，须遵循如下顺序： <ul><li>请求资源—— 如果请求资源失败，请求进程将会被阻塞或循环等待。</li><li>使用资源——-进程对资源进行操作，如用打印机进行打印</li><li>释放资源——-当进程使用完后自己释放资源。</li></ul></li><li>系统中每一类可重用性资源中的单元数目是相对固定的，进程在进行期间不能创建也不能删除它。</li></ul></li><li>可消耗性资源： <ul><li>可消耗性资源又称为临界性资源。</li></ul></li></ul></li><li>可抢占性资源和不可抢占性资源 <ul><li>可抢占性资源： <ul><li>是指某进程在获得这类资源后，该资源可以被其他进程或系统抢占。</li></ul></li><li>不可抢占性资源: <ul><li>是指一旦系统把某资源分配给该进程后，将不能将他强行收回，只能在进程用完后自行释放。</li></ul></li></ul></li></ul><h4 id="_5-2-计算机系统中的死锁" tabindex="-1"><a class="header-anchor" href="#_5-2-计算机系统中的死锁" aria-hidden="true">#</a> 5.2 计算机系统中的死锁</h4><ul><li>竞争不可抢占性资源引起死锁</li><li>竞争可消耗性资源引起死锁</li><li>进程推进顺序不当引起死锁</li></ul><h4 id="_5-3-死锁的定义、必要条件和处理方法、" tabindex="-1"><a class="header-anchor" href="#_5-3-死锁的定义、必要条件和处理方法、" aria-hidden="true">#</a> 5.3 死锁的定义、必要条件和处理方法、</h4><ul><li>死锁定义：如果一组进程中的没一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</li><li>产生死锁的必要条件 <ul><li>互斥条件</li><li>请求和保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ul></li><li>处理死锁的方法 <ul><li>预防死锁：事先预防，破坏 4 个必要条件</li><li>避免死锁： 事先预防，资源分配时防止进入不安全状态</li><li>检测死锁： 事后检测在解除死锁</li><li>解除死锁</li></ul></li></ul><h3 id="_6-预防死锁" tabindex="-1"><a class="header-anchor" href="#_6-预防死锁" aria-hidden="true">#</a> 6 预防死锁</h3><h4 id="_6-1-破坏-请求和保持-条件" tabindex="-1"><a class="header-anchor" href="#_6-1-破坏-请求和保持-条件" aria-hidden="true">#</a> 6.1 破坏“请求和保持”条件</h4><ul><li>第一种协议 <ul><li>所有进程在开始运行前，必须一次性申请所有资源</li><li>安全，简单，资源利用率低</li></ul></li><li>第二种协议 <ul><li>获得开始的资源后可以逐步申请新资源，但是得先释放旧资源</li><li>提高资源利用率</li></ul></li></ul><h4 id="_6-2-破坏不可抢占条件" tabindex="-1"><a class="header-anchor" href="#_6-2-破坏不可抢占条件" aria-hidden="true">#</a> 6.2 破坏不可抢占条件</h4><ul><li>进程提出新资源申请而不能满足时，必须释放已经保存的所有资源</li><li>进程已经占有的资源会被暂时释放</li><li>实现复杂，延长进程周转时间</li></ul><h4 id="_6-3-破坏-循环等待-条件" tabindex="-1"><a class="header-anchor" href="#_6-3-破坏-循环等待-条件" aria-hidden="true">#</a> 6.3 破坏“循环等待”条件</h4><ul><li>对所有资源进行线性排序，并赋予不同的序号</li><li>进程按照序号递增的顺序请求资源，同类资源一起请求</li><li>申请低号资源要先释放高于他的资源</li><li>资源利用率高、难以新增新设备</li></ul><h3 id="_7-避免死锁-资源分配时不让系统进入不安全状态" tabindex="-1"><a class="header-anchor" href="#_7-避免死锁-资源分配时不让系统进入不安全状态" aria-hidden="true">#</a> 7 避免死锁：资源分配时不让系统进入不安全状态</h3><h4 id="_7-1-系统的安全状态" tabindex="-1"><a class="header-anchor" href="#_7-1-系统的安全状态" aria-hidden="true">#</a> 7.1 系统的安全状态</h4><ul><li>安全状态 <ul><li>能够找到某种进程推进顺序，可以使每个进程都顺序完成</li><li>可以避免发生死锁</li><li>处于不安全状态可能会发生死锁</li></ul></li><li>安全状态之例</li><li>由安全状态向不安全状态的转换</li></ul><h4 id="_7-2-利用银行家算法避免死锁" tabindex="-1"><a class="header-anchor" href="#_7-2-利用银行家算法避免死锁" aria-hidden="true">#</a> 7.2 利用银行家算法避免死锁</h4><ul><li><p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</p></li><li><p>银行家算法中的数据结构</p><ul><li>长度为 <code>m</code> 的一维数组 <code>Available</code> 表示还有多少可用资源</li><li><code>n*m</code> 矩阵 <code>Max</code> 表示各进程对资源的最大需求数</li><li><code>n*m</code> 矩阵 <code>Allocation</code> 表示已经给各进程分配了多少资源</li><li><code>Max – Allocation = Need</code> 矩阵表示各进程最多还需要多少资源</li><li>用长度为 <code>m</code> 的一位数组 <code>Request</code> 表示进程此次申请的各种资源数</li></ul></li><li><p>银行家算法</p></li><li><p>安全性算法</p></li><li><p>银行家算法之例</p><p><img src="https://img-blog.csdnimg.cn/24ffffbe5f5640aa9794cf3dc67acf09.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/4ae333821375475baff298fa9f1c4211.png#pic_center" alt="在这里插入图片描述"></p></li></ul><h3 id="_8-死锁的检测与解除" tabindex="-1"><a class="header-anchor" href="#_8-死锁的检测与解除" aria-hidden="true">#</a> 8 死锁的检测与解除</h3><h4 id="_8-1-死锁的检测" tabindex="-1"><a class="header-anchor" href="#_8-1-死锁的检测" aria-hidden="true">#</a> 8.1 死锁的检测</h4><ul><li><p>资源分配图：</p><ul><li>表示进程对资源的访问情况</li><li>方块代表资源，方块内数字代表资源数量</li><li>圆圈代表进程</li><li>从进程指向资源表示请求资源</li><li>从资源指向进程表示分配资源</li></ul><p><img src="https://img-blog.csdnimg.cn/2d7e2b0dfab74ec6819ae61e8f52df6e.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>死锁定理</p><ul><li><p>利用资源分配图花间来检测是否死锁</p><p><img src="https://img-blog.csdnimg.cn/4506f6a5894d4b59b7142fd46ae54947.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li><li><p>死锁检测中的数据结构</p></li></ul><h4 id="_8-2-死锁的解除" tabindex="-1"><a class="header-anchor" href="#_8-2-死锁的解除" aria-hidden="true">#</a> 8.2 死锁的解除</h4><ul><li>终止进程的方法 <ul><li>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li></ul></li><li>付出代价最小的死锁解除算法</li></ul><h2 id="第四章存储器管理" tabindex="-1"><a class="header-anchor" href="#第四章存储器管理" aria-hidden="true">#</a> 第四章存储器管理</h2><h3 id="_1-存储器的层次结构" tabindex="-1"><a class="header-anchor" href="#_1-存储器的层次结构" aria-hidden="true">#</a> 1 存储器的层次结构</h3><h4 id="_1-1-多层结构的存储器系统" tabindex="-1"><a class="header-anchor" href="#_1-1-多层结构的存储器系统" aria-hidden="true">#</a> 1.1 多层结构的存储器系统</h4><ul><li>存储器的多层结构 <ul><li>最高层为 CPU 寄存器 <ul><li>寄存器</li></ul></li><li>中间为主存 <ul><li>高速缓存</li><li>主存储器</li><li>磁盘缓存</li></ul></li><li>最底层是辅存 <ul><li>固定磁盘</li><li>可移动存储介质</li></ul></li><li>寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范围。</li></ul></li><li>可执行存储器 <ul><li>在计算机系统的存储层次中，寄存器和主存储器又被称为可执行存储器</li></ul></li><li>操作系统的存储管理负责对可执行存储器的分配、回收，以及提供在存储层次间数 据移动的管理机制。</li></ul><h4 id="_1-2-主存储器与寄存器" tabindex="-1"><a class="header-anchor" href="#_1-2-主存储器与寄存器" aria-hidden="true">#</a> 1.2 主存储器与寄存器</h4><ul><li>主存储器 <ul><li>简称内存或主存</li><li>用于保存进程运行时的程序和数据。也称可执行存储器。</li></ul></li><li>寄存器 <ul><li>寄存器具有与处理机相同的速度，故对寄存器的访问速度最快</li></ul></li></ul><h4 id="_1-3-高速缓存和磁盘缓存" tabindex="-1"><a class="header-anchor" href="#_1-3-高速缓存和磁盘缓存" aria-hidden="true">#</a> 1.3 高速缓存和磁盘缓存</h4><ul><li>高速缓存 <ul><li>主要用于备份主存中比较常用的数据，以减少处理机对主存储器的访问次数，这样可大幅提高程序执行速度。</li></ul></li><li>磁盘缓存 <ul><li>主要用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数</li></ul></li></ul><h3 id="_2-程序的装入和链接" tabindex="-1"><a class="header-anchor" href="#_2-程序的装入和链接" aria-hidden="true">#</a> 2 程序的装入和链接</h3><h4 id="_2-1-程序的装入" tabindex="-1"><a class="header-anchor" href="#_2-1-程序的装入" aria-hidden="true">#</a> 2.1 程序的装入</h4><ul><li><p>绝对装入方式：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p><img src="https://img-blog.csdnimg.cn/fda1c4a924214e70a97834b116d651cf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDk2Njcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>可重定位装入方式：又称 <strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“==<strong>重定位</strong>”，将逻辑地址变）。</p><p><img src="https://img-blog.csdnimg.cn/d65b4edcd39d41b1beb34d5d6516e839.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>动态运行时的装入方式：又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从 0 开始的。装入程序把入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p><p><img src="https://img-blog.csdnimg.cn/80f849eb4cf7442ca768ef5abbbc04ed.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/67d014fc118e49849c33b36760f16e59.png#pic_center" alt="在这里插入图片描述"></p></li></ul><h4 id="_2-2-程序的链接" tabindex="-1"><a class="header-anchor" href="#_2-2-程序的链接" aria-hidden="true">#</a> 2.2 程序的链接</h4><ul><li><p>静态链接方式：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</p><p><img src="https://img-blog.csdnimg.cn/167a8da817094dff81245705541af37e.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</p><p><img src="https://img-blog.csdnimg.cn/ec59cfc5cad34c1f83d29d712855c484.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p><p><img src="https://img-blog.csdnimg.cn/3396f983f97c4c2ab9e318a2cc836034.png#pic_center" alt="在这里插入图片描述"></p></li></ul><h3 id="_3-连续分配存储管理方式" tabindex="-1"><a class="header-anchor" href="#_3-连续分配存储管理方式" aria-hidden="true">#</a> 3 连续分配存储管理方式</h3><h4 id="_3-1-单一连续分配" tabindex="-1"><a class="header-anchor" href="#_3-1-单一连续分配" aria-hidden="true">#</a> 3.1 单一连续分配</h4><ul><li><p>用于单道程序环境</p></li><li><p>内存被分为 <strong>系统区</strong> 和 <strong>用户区</strong>。</p></li><li><p>系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</p></li><li><p>优点： <strong>实现简单；无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）</p></li><li><p><strong>缺点</strong>：只能用于单用户、单任务的操作系统中；<strong>有内部碎片；存储器利用率极低</strong>。 <strong>【分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”】</strong></p><p><img src="https://img-blog.csdnimg.cn/13231e604892466da3eff9c44432788c.png#pic_center" alt="在这里插入图片描述"></p></li></ul><h4 id="_3-2-固定分区分配" tabindex="-1"><a class="header-anchor" href="#_3-2-固定分区分配" aria-hidden="true">#</a> 3.2 固定分区分配</h4><ul><li><p>划分分区的方法</p><ul><li><strong>分区大小相等</strong>：缺乏灵活性，但是很<strong>适合用于用一台计算机控制多个相同对象的场合</strong>（比如：钢铁厂有 n 个相同的炼钢炉，就可把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序）</li><li><strong>分区大小不等</strong>：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）</li></ul></li><li><p>内存分配</p><p><img src="https://img-blog.csdnimg.cn/030e3ac001b0458cb929eceb0bf3f222.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2d2a817ec95541378ccfa1e8fdb22fa1.png#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>优点：实现简单，无外部碎片。</strong></li><li><strong>缺点：</strong> a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能； b. <strong>会产生内部碎片，内存利用率低。</strong></li></ul></li></ul><h4 id="_3-3-动态分区分配" tabindex="-1"><a class="header-anchor" href="#_3-3-动态分区分配" aria-hidden="true">#</a> 3.3 动态分区分配</h4><ul><li><p><strong>动态分区分配</strong>又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）</p></li><li><p>动态分区分配中的数据结构</p><ul><li><p>空闲分区表：分区号、分区大小、分区始址</p></li><li><p>空闲分区链</p><p><img src="https://img-blog.csdnimg.cn/f79ec47a4ef14c97a5d10c1930c766af.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li><li><p>动态分区分配算法</p></li><li><p>分区分配操作</p><ul><li><p>分配内存</p></li><li><p>回收内存</p><ul><li><p>情况一：回收区的后面有一个相邻的空闲分区</p><p><img src="https://img-blog.csdnimg.cn/e045faaa4da74fccb1a256cfcc10b3a5.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>情况二：回收区的前面有一个相邻的空闲分区</p><p><img src="https://img-blog.csdnimg.cn/bcc66682957d47c88f69cf23683680fb.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>情况三：回收区的前、后各有一个相邻的空闲分区</p><p><img src="https://img-blog.csdnimg.cn/e755762fd6964658880141d525af2c4e.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>情况四：回收区的前、后都没有相邻的空闲分区</p><p><img src="https://img-blog.csdnimg.cn/12bb10d950aa4b37a0fcf99897fe3e27.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li></ul></li></ul><h4 id="_3-4-基于顺序搜索的动态分区分配算法" tabindex="-1"><a class="header-anchor" href="#_3-4-基于顺序搜索的动态分区分配算法" aria-hidden="true">#</a> 3.4 基于顺序搜索的动态分区分配算法</h4><ul><li><p>首次适应（FF）算法 <strong>空闲分区以地址递增依次链接</strong></p><ul><li>要求空闲分区以地址递增依次链接</li><li>每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。</li></ul></li><li><p>循环首次适应（NF）算法</p><ul><li>从上一次查找的下一个分区开始查找</li></ul></li><li><p>最佳适应（BF）算法 <strong>按照空间大小从小到大排序 使用最小的</strong></p><ul><li>由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。</li></ul></li><li><p>最坏适应（WF）算法 **按照空间大小从大到小排序 **</p><ul><li>为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201119142752182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul><h4 id="_3-5-基于索引搜索的动态分区分配算法" tabindex="-1"><a class="header-anchor" href="#_3-5-基于索引搜索的动态分区分配算法" aria-hidden="true">#</a> 3.5 基于索引搜索的动态分区分配算法</h4><ul><li>快速适应算法 <ul><li>将空闲分区按照大小进行分类，相同的一类就设立一个空闲分区表，这样就有不同的空闲分区表。作业分配的时候，就在表中选择适当大小的空闲分区分配。</li><li>优点：不会对任何分分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会差生内存碎片。查找效率高</li><li>缺点： <ol><li>为了合并有效分区，在分区归还内存是的算法复杂，系统开销较大。</li><li>空间换时间 在分配空闲分区中，是以进程为单位，一个分区只属于一个进程，或多或少存在浪费。</li></ol></li></ul></li><li>伙伴系统 <ul><li>所有分区均为 2^k</li></ul></li><li>哈希算法 <ul><li>构造一张以空闲分区大小为关键字的哈希表，记录空闲分区的链表表头指针。</li></ul></li></ul><h4 id="_3-6-动态可重定位分区分配" tabindex="-1"><a class="header-anchor" href="#_3-6-动态可重定位分区分配" aria-hidden="true">#</a> 3.6 动态可重定位分区分配</h4><ul><li>紧凑 <ul><li>对碎片进行拼接</li></ul></li><li>动态重定位 <ul><li>增加重定位寄存器，存放程序在内存中起始地址</li></ul></li><li>动态重定位分区分配算法 <ul><li>与动态分区分配算法相同，增加紧凑功能</li></ul></li></ul><h3 id="_4-对换" tabindex="-1"><a class="header-anchor" href="#_4-对换" aria-hidden="true">#</a> 4 对换</h3><h4 id="_4-1-多道程序环境下的对换技术" tabindex="-1"><a class="header-anchor" href="#_4-1-多道程序环境下的对换技术" aria-hidden="true">#</a> 4.1 多道程序环境下的对换技术</h4><ul><li>是指把内存中暂时不能运行的进程或者暂时不用的程序和数据换出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据换入内存</li><li>对换的类型： <ul><li>整体对换 <ul><li>以进程作为对换单位。</li><li>处理机中级调度就是存储器的对换功能。</li><li>用于多道程序系统中，并作为处理机的中级调度。</li></ul></li><li>页面（分段）对换 <ul><li>以页面/分段作为对换单位。</li><li>页面对换与分段对换统称为部分对换。</li><li>是请求分页与请求分段式存储管理的基础。</li></ul></li></ul></li></ul><h4 id="_4-2-对换内存空间的管理" tabindex="-1"><a class="header-anchor" href="#_4-2-对换内存空间的管理" aria-hidden="true">#</a> 4.2 对换内存空间的管理</h4><ul><li>对换空间管理的主要目标 <ul><li>对文件区管理的主要目标： <ul><li>优先提高存储空间利用率，后提高对文件访问速度。</li><li>采用离散分配方式</li></ul></li><li>对对换空间管理的主要目标： <ul><li>优先提高进程交换速度，后提高文件存储空间利用率。</li><li>采用连续分配方式。</li></ul></li></ul></li><li>对换区空闲盘块管理中的数据结构 <ul><li>与动态分区分配相似，可以使用空闲分区表与空闲分区链。</li><li>空闲分区表中，包含： <ul><li>对换区首地址-盘块号。</li><li>对换区大小-盘块数。</li></ul></li></ul></li><li>对换空间的分配与回收 <ul><li>分配方式与动态分区方式相似，可用如下算法： <ul><li>首次适应算法。</li><li>循环首次适应算法。</li><li>最佳适应算法。</li></ul></li><li>回收方式与回收内存方式一样，对以下四种情况进行处理： <ul><li>前有空闲分区。</li><li>后有空闲分区。</li><li>前后有空闲分区。</li><li>前后无空闲分区。</li></ul></li></ul></li></ul><h4 id="_4-3-进程的换出与换入" tabindex="-1"><a class="header-anchor" href="#_4-3-进程的换出与换入" aria-hidden="true">#</a> 4.3 进程的换出与换入</h4><ul><li>进程的换出 <ul><li>选择被换出的进程 <ul><li>检查内存中进程，优先选择阻塞/睡眠状态的进程，再选择其中优先级最低的进程作为换出进程。</li><li>无阻塞进程时，选择其中优先级最低的进程。</li><li>为了防止低优先级进程频繁出入，进程的驻留时间也应纳入考虑。</li></ul></li><li>进程换出过程 <ul><li>只能换出非共享的程序与数据段。</li><li>换出时，先申请对换空间，成功后，启动磁盘，将待兑换数据传入磁盘对换区中。</li><li>传送成功，无出错后，回收进程所占用内存空间，并修改相应数据结构。</li><li>若换出进程后，依然有阻塞/睡眠进程，则继续换出。</li></ul></li></ul></li><li>进程的换入 <ul><li>定时执行换入操作 <ul><li>查看 PCB 集合中所有进程状态，找出“就绪”且已换出的进程。</li><li>数量足够多时，选择其中驻留时间足够，且驻留最久的进程作为换入内存</li><li>若换入失败，则先将内存中进程换出，再进行换入</li><li>若换入成功后，还有可换入进程，则继续换入，直到无“就绪”且已换出进程，或无足够内存为止。</li></ul></li><li>常用的对换方案： <ul><li>在进程运行时经常缺页且内存紧张，才启动对换程序。</li><li>若缺页率减少，系统吞吐量下降，则暂停对换程序。</li></ul></li></ul></li></ul><h3 id="_5-分页存储管理方式" tabindex="-1"><a class="header-anchor" href="#_5-分页存储管理方式" aria-hidden="true">#</a> 5 分页存储管理方式</h3><h4 id="_5-1-分页存储管理的基本方法" tabindex="-1"><a class="header-anchor" href="#_5-1-分页存储管理的基本方法" aria-hidden="true">#</a> 5.1 分页存储管理的基本方法</h4><ul><li><p>页面和物理块</p><ul><li>分页存储管理是将一个进程的<strong>逻辑地址空间</strong>分成<strong>若干个大小相等</strong>的片称为页，并为各页加以编号，从 0 开始。</li><li>同时把内存空间分成与<strong>页面相同大小</strong>的若<strong>干个存储块</strong>，称为块。</li><li>在为进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以<strong>不相邻</strong>的物理块中。</li></ul></li><li><p>地址结构</p><p><img src="https://img-blog.csdnimg.cn/20201119211325472.png#pic_center" alt="在这里插入图片描述"></p><ul><li>若给定一个逻辑地址空间中的地址为 A，页面大小为 L，则: <ul><li>页号： P=INT[A/L]</li><li>页内地址： d=[A] MOD L</li></ul></li><li>例如：系统页面大小为 1KB，设 A=2170B，则:P=2，d=122</li></ul></li><li><p>页表</p><ul><li><p>页面映射表</p><p><img src="https://img-blog.csdnimg.cn/20201119213509195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>实现进程的逻辑页号到物理块号的映射</p></li><li><p>逻辑页号、物理块号、存储控制字段</p></li></ul></li></ul><h4 id="_5-2-地址变换机构" tabindex="-1"><a class="header-anchor" href="#_5-2-地址变换机构" aria-hidden="true">#</a> 5.2 地址变换机构</h4><ul><li><p>基本的地址变换机构</p><ul><li><p>实现从逻辑地址到物理地址的转换，其任务是借助于页表，将逻辑地址中的页号转换为内存中的物理块号。</p></li><li><p>页表可以由一组专门的寄存器来实现，一个页表项用一个寄存器。但寄存器成本高，系统页表可能很大，所以页表大多常驻内存。</p></li><li><p>在系统中只设置一个页表寄存器 PTR，在其中存放页表在内存中的始址和页表的长度。</p><p><img src="https://img-blog.csdnimg.cn/20201119213554215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>地址转换步骤</p><ul><li>当逻辑地址为十进制时： <ul><li>求出逻辑地址的页号 = 逻辑地址 / 页面大小</li><li>求出页内偏移量 = 逻辑地址 % 页面大小</li><li>用页号查页表，得到块号；</li><li>求出物理地址 = 块号 * 页面大小 + 页内偏移</li></ul></li><li>当逻辑地址为十六进制/八进制/二进制时: <ul><li>把逻辑地址转为二进制；</li><li>按页的大小分离出页号和页内偏移量（ 高位部分为页号，低位部分为页内偏移量 ）；</li><li>以页号查页表，得到物理地址的块号；</li><li>将逻辑地址的页内偏移量直接复制到物理地址的块内偏移量上；</li><li>把块号转为二进制，从而得出物理地址，再转回 16/8 进制。</li></ul></li></ul></li></ul></li><li><p>具有快表的地址变换结构</p><ul><li><p>在地址变换机构中，增设一个具有<strong>并行查寻能力</strong>的特殊<strong>高速缓冲寄存器</strong>，称为**“联想存储器”或“快表”**。（默认先访问块表再访问页表，如同时访问会给出备注）</p><p><img src="https://img-blog.csdnimg.cn/2020111922011581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="_5-3-访问内存的有效时间" tabindex="-1"><a class="header-anchor" href="#_5-3-访问内存的有效时间" aria-hidden="true">#</a> 5.3 访问内存的有效时间</h4><h4 id="_5-4-两级和多级页表" tabindex="-1"><a class="header-anchor" href="#_5-4-两级和多级页表" aria-hidden="true">#</a> 5.4 两级和多级页表</h4><ul><li><p>两级页表</p><p><img src="https://img-blog.csdnimg.cn/20201119224739341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>多级页表</p><ul><li><p>多级套娃</p><p><img src="https://img-blog.csdnimg.cn/20201119225734339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="_5-5-反置页表" tabindex="-1"><a class="header-anchor" href="#_5-5-反置页表" aria-hidden="true">#</a> 5.5 反置页表</h4><ul><li>系统<strong>只需设置一个反置页表</strong>，为所有进程所共用。</li><li>置页表是面向内存物理块的，即<strong>对应内存的每个物理块设置一个表项</strong>，表项的序号就是物理块号 f，表项的内容则为进程标识 pid 与逻辑页号 p 的有序对；</li></ul><h3 id="_6-分段存储管理方式" tabindex="-1"><a class="header-anchor" href="#_6-分段存储管理方式" aria-hidden="true">#</a> 6 分段存储管理方式</h3><h4 id="_6-1-分段存储管理方式的引入" tabindex="-1"><a class="header-anchor" href="#_6-1-分段存储管理方式的引入" aria-hidden="true">#</a> 6.1 分段存储管理方式的引入</h4><ul><li>方便编程：按逻辑关系分为若干个段，每个段从 0 编址，并有名字和长度，访问的逻辑地址由段名和段内偏移量决定。</li><li>信息共享：共享是以信息为逻辑单位，页是存储信息的物理单位，段却是信息的逻辑单位</li><li>信息保护：保护也是对信息的逻辑单位进行保护的。</li><li>动态增长：实际应用中，某些段（<strong>数据段）会不断增长</strong>，前面的存储管理方法均难以实现。</li><li>动态链接：<strong>动态链接以段为单位</strong>。</li></ul><h4 id="_6-2-分段系统的基本原理" tabindex="-1"><a class="header-anchor" href="#_6-2-分段系统的基本原理" aria-hidden="true">#</a> 6.2 分段系统的基本原理</h4><ul><li><p>分段</p><ul><li>将用户作业的逻辑地址空间划分成若干个大小不等的段（由用户<strong>根据逻辑信息的相对完整</strong>来划分）。各段有段名（常用段号代替），首地址为 0。</li></ul></li><li><p>段表</p><p><img src="https://img-blog.csdnimg.cn/20201121141959723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>地址变换机构</p><p><img src="https://img-blog.csdnimg.cn/20201121145708650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>分页和分段的主要区别</p><ul><li>页是信息的物理单位，用户不可见，段是逻辑单位，用户可见</li><li>页的大小固定且由系统决定，段长由用户程序决定</li><li>分页是提高内存利用率，分段是满足用户需求</li><li>分页地址空间是一维的，分段是二维</li></ul></li></ul><h4 id="_6-3-信息共享" tabindex="-1"><a class="header-anchor" href="#_6-3-信息共享" aria-hidden="true">#</a> 6.3 信息共享</h4><ul><li>分段系统的一个突出优点是易于实现段的共享，允许<strong>若干个进程共享一个或多个分段</strong>，且<strong>对段的保护</strong>十分简单易行。</li><li>如果多个用户进程或作业需要共享某段程序或数据，<strong>可以使用不同的段名</strong>，在各自的段表中填入已在内存中的共享段的起始地址，<strong>并设置适当的读写控制权</strong>，就可以做到共享一个内存段的信息。</li></ul><h4 id="_6-4-段页式存储管理方式" tabindex="-1"><a class="header-anchor" href="#_6-4-段页式存储管理方式" aria-hidden="true">#</a> 6.4 段页式存储管理方式</h4><ul><li><p>段式优于页式 便于共享和保护</p></li><li><p>页式优于段式 消除“外碎片”问题</p></li><li><p>段页式：结合二者优点 每个进程包含若干段 每个段包含若干页</p></li><li><p>基本原理</p><ul><li>内存空间划分：(同页式) 静态等长，2i, 称为一块。 物理地址=(块号,块内地址)=(f,w)</li><li>进程空间划分： 一个进程&lt;–&gt;若干个段 一个段&lt;–&gt;若干个页 逻辑地址=(段号, 逻辑页号, 页内地址)=(s,p,w)</li></ul></li><li><p>地址变换过程</p><p><img src="https://img-blog.csdnimg.cn/20201121164908437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTE1Mzc4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ul><h2 id="第五章-虚拟存储器" tabindex="-1"><a class="header-anchor" href="#第五章-虚拟存储器" aria-hidden="true">#</a> 第五章 虚拟存储器</h2><h3 id="_1-虚拟存储器概述" tabindex="-1"><a class="header-anchor" href="#_1-虚拟存储器概述" aria-hidden="true">#</a> 1 虚拟存储器概述</h3><h4 id="_1-1-常规存储管理方式的特征和局部性原理" tabindex="-1"><a class="header-anchor" href="#_1-1-常规存储管理方式的特征和局部性原理" aria-hidden="true">#</a> 1.1 常规存储管理方式的特征和局部性原理</h4><ul><li>常规存储器管理方式的特征 <ul><li>一次性，是指作业必须一次性地全部装入内存后方能开始运行。</li><li>驻留性：是指作业被装入内存后，整个作业都一直驻留在内存中，其中任何部分都不会被换出，直至作业运行结束。</li></ul></li><li>局部性原理 <ul><li>程序执行时，除了少部分的转移和过程调用指令外，在大多数情况下是顺序执行的。</li><li>过程调用将会使程序的执行轨迹由一部份区域转至另一部份区域。</li><li>程序中存在许多循环结构，这些结构虽然只由少数指令组成，但是它们将被多次执行。</li><li>程序中还包括许多对数据结构的处理。</li><li>时间局限性：存在大量的循环</li><li>空间局限性：程序顺序执行</li></ul></li><li>虚拟存储器的基本工作情况 <ul><li>根据局部性原理，只装入部分程序开始运行</li><li>若访问的段页不存在就缺页中断</li><li>由系统请求调页功能再调入内存</li><li>若内存满则置换在调入</li></ul></li></ul><h4 id="_1-2-虚拟存储器的定义和特征" tabindex="-1"><a class="header-anchor" href="#_1-2-虚拟存储器的定义和特征" aria-hidden="true">#</a> 1.2 虚拟存储器的定义和特征</h4><ul><li>虚拟存储器的定义（VM） <ul><li>从逻辑上进行扩充</li></ul></li><li>虚拟存储器的特征 <ul><li>多次性：即只需将当前要运行的那部分程序和数据装入内存即可开始运行。 以后每当要运行到尚未调入的那部分程序时，再将它调入。</li><li>对换性：即在进程运行期间，允许那些暂不使用的代码和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换进）。甚至还允许将暂时不运行的进程调至外存，待它们重又具备运行条件时在调入内存。</li><li>虚拟性：指能够从逻辑上扩充内存容量，使用户看到的内存容量远大于实际内存容量。</li></ul></li></ul><h4 id="_1-3-虚拟存储器的实现方法" tabindex="-1"><a class="header-anchor" href="#_1-3-虚拟存储器的实现方法" aria-hidden="true">#</a> 1.3 虚拟存储器的实现方法</h4><ul><li>分页请求系统 <ul><li>分页请求系统是在分页系统的基础上增加了‘调页功能’和‘页面置换功能’所形成的页式页式虚拟存储系统。</li><li>硬件支持： <ul><li>请求分页的页表机制</li><li>缺页中断机构</li><li>地址变换机构</li></ul></li><li>实现请求分页的软件</li></ul></li><li>请求分段系统 <ul><li>请求分段系统是在分段系统的基础上，增加了请求调段及分段置换功能后 所形成的段式虚拟存储系统。</li><li>硬件支持： <ul><li>请求分段的页表机制</li><li>缺段中断机构</li><li>地址变换机构</li></ul></li><li>实现请求分段的软件</li></ul></li></ul><h3 id="_2-请求分页存储管理方式" tabindex="-1"><a class="header-anchor" href="#_2-请求分页存储管理方式" aria-hidden="true">#</a> 2 请求分页存储管理方式</h3><h4 id="_2-1-请求分页中的硬件支持" tabindex="-1"><a class="header-anchor" href="#_2-1-请求分页中的硬件支持" aria-hidden="true">#</a> 2.1 请求分页中的硬件支持</h4><ul><li>请求页表机制 <ul><li>页号</li><li>物理块号</li><li>状态为 P： 0:不在内存。1：在内存</li><li>访问字段 A： 访问次数或者未访问时间</li><li>修改位 M： 是否被修改</li><li>外存地址： 磁盘地址</li></ul></li><li>缺页中断机构 <ul><li>访问的页不在内存时，请求 OS 调入</li></ul></li><li>地址变换机构</li></ul><h4 id="_2-2-请求分页中的内存分配" tabindex="-1"><a class="header-anchor" href="#_2-2-请求分页中的内存分配" aria-hidden="true">#</a> 2.2 请求分页中的内存分配</h4><ul><li>最小物理块数的确定 <ul><li>保证进程运行的最小物理块</li></ul></li><li>内存分配策略 <ul><li>固定分配局部置换：固定分配物理块，缺页时只换出一页</li><li>可变分配全局置换：物理块运行中可以变化物理块个数，缺页时分配物理块或者换一页</li><li>可变分配局部置换：根据缺页率改变物理块，缺页换出页面</li></ul></li><li>物理块分配算法 <ul><li>平均分配算法：将所有物理块平均分</li><li>按比例分配算法：</li><li>考虑优先权的分配算法：一部分按比例，一部分按优先权</li></ul></li></ul><h4 id="_2-3-页面调入策略" tabindex="-1"><a class="header-anchor" href="#_2-3-页面调入策略" aria-hidden="true">#</a> 2.3 页面调入策略</h4><ul><li><p>何时调入页面</p><ul><li>预调页策略 <ul><li>以预测为基础，预计调入以后会访问的页面</li></ul></li><li>请求调页策略 <ul><li>发生中断时才请求</li></ul></li></ul></li><li><p>从何处调入页面</p><ul><li>文件区和对换区</li><li>文件区离散分配访问慢，对换区连续分配访问快</li><li>有足够大对换空间，全部从对换区调入</li><li>对换区不够，未被修改的文件从文件区调入，修改的从对换区</li></ul></li><li><p>页面调入过程</p><ul><li>访问页表的存在位 0 发出缺页中断</li><li>中断机构保留断点和 CPU 环境</li><li>根据根据页表查找外存地址</li><li>内存有空闲则调入，修改页表和块表</li><li>满了则按照算法换出一页在调入根据修改的页表访问调入页</li></ul></li><li><p>缺页率</p><ul><li>影响缺页率的因素 <ul><li>页面大小，越大缺页率越小</li><li>物理块数，越多越小</li><li>页面置换算法</li><li>程序特性</li></ul></li></ul></li></ul><h3 id="_3-页面置换算法" tabindex="-1"><a class="header-anchor" href="#_3-页面置换算法" aria-hidden="true">#</a> 3 页面置换算法</h3><h4 id="_3-1-最佳置换算法和先进先出置换算法" tabindex="-1"><a class="header-anchor" href="#_3-1-最佳置换算法和先进先出置换算法" aria-hidden="true">#</a> 3.1 最佳置换算法和先进先出置换算法</h4><ul><li><p>最佳置换算法</p><ul><li>每次选择<strong>淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</li><li><strong>最佳置换算法是无法实现的。</strong></li></ul></li><li><p>先进先出（FIFO）页面置换算法</p><ul><li><p>每次选择<strong>淘汰的页面</strong>是<strong>最早进入内存的页面</strong></p><p><img src="https://img-blog.csdnimg.cn/9b812874e59140ec9fe94ef7b2cc4fd4.png#pic_center" alt="在这里插入图片描述"></p></li><li><p><strong>Belady 异常</strong>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p></li><li><p><strong>只有 FIFO 算法会产生 Belady 异常</strong>。另外，FIFO 算法虽然<strong>实现简单</strong>，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<strong>算法性能差</strong></p></li></ul></li></ul><h4 id="_3-2-最近最久未使用和最少使用置换算法" tabindex="-1"><a class="header-anchor" href="#_3-2-最近最久未使用和最少使用置换算法" aria-hidden="true">#</a> 3.2 最近最久未使用和最少使用置换算法</h4><ul><li><p>最近最久未使用置换算法（LRU）</p><ul><li><p>每次<strong>淘汰的页面</strong>是<strong>最近最久未使用的页面</strong></p></li><li><p>实现方法：赋予每个页面对应的页表项中，用<strong>访问字段记录该页面自上次被访问以来所经历的时间 t。</strong></p><p><img src="https://img-blog.csdnimg.cn/1911751d50a14bbbbafd5a73accd698e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYmZob25vcg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></li><li><p>该算法的实现需要专门的硬件支持，虽然算法<strong>性能好</strong>，但是<strong>实现困难，开销大</strong></p></li></ul></li></ul><h4 id="_3-3-clock-置换算法" tabindex="-1"><a class="header-anchor" href="#_3-3-clock-置换算法" aria-hidden="true">#</a> 3.3 Clock 置换算法</h4><ul><li><p>为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针链接成一个循环队列。</p></li><li><p>当某页被访问时，其访问位置为 1。当需要淘汰一个页面时，只需检查页的访问位。</p></li><li><p>如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描（第二轮扫描中一定会有访问位为 0 的页面，因此<strong>简单的 CLOCK</strong> 算法选择一个淘汰页面<strong>最多会经过两轮扫描</strong>）</p></li><li><p>改进型 Clock 算法</p><ul><li><p>除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。<strong>在其他条件都相同时，应优先淘汰没有修改过的页面</strong>，避免 I/O 操作。这就是改进型的时钟置换算法的思想。</p><p><img src="https://img-blog.csdnimg.cn/fad3212a890c422fbde20ef95af49cea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYmZob25vcg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/8a3202d18517480ba3080407ae974812.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYmZob25vcg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></li></ul><h4 id="_3-4-页面缓冲算法" tabindex="-1"><a class="header-anchor" href="#_3-4-页面缓冲算法" aria-hidden="true">#</a> 3.4 页面缓冲算法</h4><ul><li>影响页面换进换出效率的若干因素 <ul><li>页面置换算法</li><li>写回磁盘的频率</li><li>读入内存的频率</li></ul></li><li>页面缓冲算法 <ul><li>降低页面换进换出频率</li><li>实现简单</li><li>空闲页面链表：减小页面换进开销</li><li>修改页面链表：减小已修改页面换出次数</li></ul></li></ul><h4 id="_3-5-访问内存的有效时间" tabindex="-1"><a class="header-anchor" href="#_3-5-访问内存的有效时间" aria-hidden="true">#</a> 3.5 访问内存的有效时间</h4><ul><li>存在三种方式的内存访问操作： （1）被访问页在内存中，且其对应的页表项在块表中。 内存有效访问时间（EAT）分为查找快表的时间（λ）和 访问实际物理地址所需的时间（t）。 EAT = λ + t （2）被访问页在内存中，且其对应的页表项不再快表中。 EAT = λ + t + λ + t = 2 ×（λ + t） （3）被访问页不在内存中。 EAT = λ + a × t + (1 - a) × [t + f × (ε + λ + t) + (1 - f) × （λ + t ）] 式中，a 表示命中率，f 表示缺页率。 如果不考命中率，仅考虑虑缺页率即 λ = 0 和 a = 0， 设缺页中断处理时间为 Φ，则： EAT = t + f × (Φ + t) + (1 -f) × t</li></ul><h3 id="_4-抖动-与工作集" tabindex="-1"><a class="header-anchor" href="#_4-抖动-与工作集" aria-hidden="true">#</a> 4 “抖动”与工作集</h3><h4 id="_4-1-多道程序度与-抖动" tabindex="-1"><a class="header-anchor" href="#_4-1-多道程序度与-抖动" aria-hidden="true">#</a> 4.1 多道程序度与“抖动</h4><ul><li>多道程序度与处理机的利用率 <ul><li>多道程序度：系统允许同时运行的程序道数</li></ul></li><li>产生“抖动”的原因 <ul><li>系统中同时运行的进程太多</li><li>每个进程的物理块太少</li><li>频繁缺页</li><li>进程都在等待不能正常工作</li></ul></li></ul><h4 id="_4-2-工作集" tabindex="-1"><a class="header-anchor" href="#_4-2-工作集" aria-hidden="true">#</a> 4.2 工作集</h4><ul><li>工作集是指在某段时间间隔 ∆ 里，进程实际要访问的页面的集合。</li><li>工作集的大小是变化的。</li></ul><h4 id="_4-3-抖动-的预防方法" tabindex="-1"><a class="header-anchor" href="#_4-3-抖动-的预防方法" aria-hidden="true">#</a> 4.3 “抖动”的预防方法</h4><ul><li>采取局部置换策略：仅允许进程在自身范围内进行置换。即使发生抖动，也可以把影响限制在较小范围内</li><li>在处理机调度中引入工作集策略：缺页高则先增加页面而不调入新作业</li><li>用 L=S 准则调节缺页率：l&gt;s 很少缺页 l&lt;s 频繁缺页 l=s 利用率最高</li><li>选择暂停的进程：暂停优先级最低的进程</li></ul><h3 id="_5-请求分段存储管理方式" tabindex="-1"><a class="header-anchor" href="#_5-请求分段存储管理方式" aria-hidden="true">#</a> 5 请求分段存储管理方式</h3><h4 id="_5-1-请求分段中的硬件支持" tabindex="-1"><a class="header-anchor" href="#_5-1-请求分段中的硬件支持" aria-hidden="true">#</a> 5.1 请求分段中的硬件支持</h4><ul><li><p>请求段表机制</p><ul><li>段名</li><li>段长</li><li>段基址</li><li>存取方式 读、写、执行</li><li>访问字段 A</li><li>修改位 M</li><li>存在位 P</li><li>增补位 运行时是否有动态增长</li><li>外存始址</li></ul></li><li><p>缺段中断机构</p><ul><li>采取请求调段策略，缺段发生中断</li></ul></li><li><p>地址变换机构</p></li></ul><h4 id="_5-2-分段的共享与保护" tabindex="-1"><a class="header-anchor" href="#_5-2-分段的共享与保护" aria-hidden="true">#</a> 5.2 分段的共享与保护</h4><ul><li>共享段表 <ul><li>共享进程计数 count</li><li>存取控制字段</li><li>段号</li></ul></li><li>共享段的分配与回收 <ul><li>共享段的分配：第一个进程调入，共享段表加一，计数置 1</li><li>共享段的回收：计数减 1，计数为 0 则释放段内存</li></ul></li><li>分段保护 <ul><li>越界检查</li><li>存取控制检查</li><li>环保护机构 <ul><li>一个程序可以访问驻留在相同环或较低特权环（外环）中的服务。</li><li>一个程序可以调用驻留在相同环或较高级特权环（内环）中的服务。</li></ul></li></ul></li></ul><h2 id="第六章-输入输出系统" tabindex="-1"><a class="header-anchor" href="#第六章-输入输出系统" aria-hidden="true">#</a> 第六章 输入输出系统</h2><h3 id="_1-i-o-系统的功能、模型和接口" tabindex="-1"><a class="header-anchor" href="#_1-i-o-系统的功能、模型和接口" aria-hidden="true">#</a> 1 I/O 系统的功能、模型和接口</h3><ul><li>I/O 系统管理对象主要是 I/O 设备和相应的设备控制器，主要任务是完成用户提出的 I/O 请求，提高 I/O 速率，提高设备利用率</li></ul><h4 id="_1-1-i-o-系统的基本功能" tabindex="-1"><a class="header-anchor" href="#_1-1-i-o-系统的基本功能" aria-hidden="true">#</a> 1.1 I/O 系统的基本功能</h4><ul><li>隐藏物理设备的细节</li><li>与设备的无关性</li><li>提高处理机和 I/O 设备的利用率</li><li>对 I/O 设备进行控制 <ul><li>采用轮询的可编程 I/O 方式</li><li>采用中断的可编程 I/O 方式</li><li>直接存储器访问方式</li><li>I/O 通道方式</li></ul></li><li>确保对设备的正确共享</li><li>错误处理</li></ul><h4 id="_1-2-i-o-系统的层次结构和模型" tabindex="-1"><a class="header-anchor" href="#_1-2-i-o-系统的层次结构和模型" aria-hidden="true">#</a> 1.2 I/O 系统的层次结构和模型</h4><ul><li><p>I/O 软件的层次结构</p><ul><li><p>用户层 I/O 软件：实现与用户交互的接口，用户可直接调用该层所提供的、与 I/O 操作有关的库函数对设备进行操作</p></li><li><p>设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间</p></li><li><p>设备驱动程序：与<strong>硬件</strong>直接相关，用于具体实现系统对设备发出的操作指令，驱动 I/O 设备工作的驱动程序</p></li><li><p>中断处理程序：CPU 先保护被中断进程的 CPU 环境，再转入相应的的中断处理程序进行处理，处理完毕后 CPU 再恢复被中断进程的现场，返回到被中断的进程</p><p><img src="https://img-blog.csdnimg.cn/22a7198b386048afaccbc56859e603a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li><li><p>I/O 系统中各种模块之间的层次视图<img src="https://img-blog.csdnimg.cn/75a741f72c4c493f99a5f692c36eb60c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h4 id="_1-3-i-o-系统的接口" tabindex="-1"><a class="header-anchor" href="#_1-3-i-o-系统的接口" aria-hidden="true">#</a> 1.3 I/O 系统的接口</h4><ul><li>块设备接口 <ul><li>块设备：是指数据的存取和传输都是以数据块位单位的设备，典型的比如磁盘，特征一是传输效率较高，通常是 MB/S 二是可寻址，即能指定数据的输入源地址和输出的目标地址，可随机地读/写磁盘中任一块。磁盘设备的 I/O 常采用 DMA 方式。</li></ul></li><li>流设备接口 <ul><li>流设备接口是流设备管理程序与高层之间的接口。该接口又称为字符设备接口，它反映了大部分字符设备的本质特征，用于控制字符设备的输入或输出。</li></ul></li><li>网络通信接口 <ul><li>在现代 OS 中，都提供了面向网络的功能。但首先还需要通过某种方式把计算机连接到网络上。同时操作系统也必须提供相应的网络软件和网络通信接口，使计算机能通过网络与网络上的其它计算机进行通信或上网浏览。</li></ul></li></ul><h3 id="_2-i-o-设备和设备控制器" tabindex="-1"><a class="header-anchor" href="#_2-i-o-设备和设备控制器" aria-hidden="true">#</a> 2 I/O 设备和设备控制器</h3><h4 id="_2-1i-o-设备" tabindex="-1"><a class="header-anchor" href="#_2-1i-o-设备" aria-hidden="true">#</a> 2.1I/O 设备</h4><ul><li><p>I/O 设备类型</p></li><li><p>设备与控制器之间的接口</p><ul><li><p>设备并不是直接与 CPU 进行通信，而是与设备控制器通信，因此，在 I/O 设备中应含有与设备控制器间的接口，在该接口中有三种类型的信号，各对应一条信号线</p><ul><li>数据信号线</li><li>控制信号线</li><li>状态信号线</li></ul><p><img src="https://img-blog.csdnimg.cn/bfc58913afd44c2ea338c77439bce7a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="_2-2-设备控制器" tabindex="-1"><a class="header-anchor" href="#_2-2-设备控制器" aria-hidden="true">#</a> 2.2 设备控制器</h4><ul><li>设备控制器的基本功能 <ul><li>接收和识别命令</li><li>数据交换</li><li>标识和报告设备的状态</li><li>地址识别</li><li>数据缓冲区</li><li>差错控制</li></ul></li><li>设备控制器的组成 <ul><li>设备控制器与处理机的接口 <ul><li>数据线---- 数据寄存器，控制/状态寄存器</li><li>地址线</li><li>控制线</li></ul></li><li>设备控制器与设备的接口</li><li>I/O 逻辑</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/12a8cbd7172248e697be8801845fd982.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="_2-3-内存映像-i-o" tabindex="-1"><a class="header-anchor" href="#_2-3-内存映像-i-o" aria-hidden="true">#</a> 2.3 内存映像 I/O</h4><ul><li><p>利用待定的 I/O 指令</p><p><img src="https://img-blog.csdnimg.cn/b1c436b887b2461ca297c01c243f21e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>内存映像 I/O</p><ul><li><p>在这种方式中，在编址上不再区分内存单元地址和设备控制器中的寄存器地址，都采用 k。当 k 值处于 0 ～ n-1 范围时，被认为是内存地址，若 k 大于等于 n 时，被认为是某个控制器的寄存器地址</p><p><img src="https://img-blog.csdnimg.cn/2c2f8ffcebae4800bf80164c453113a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="_2-4-i-o-通道" tabindex="-1"><a class="header-anchor" href="#_2-4-i-o-通道" aria-hidden="true">#</a> 2.4 I/O 通道</h4><ul><li><p>I/O 通道设备的引入</p><ul><li>虽然在 CPU 与 I/O 设备之间增加了设备控制器后，已能大大减少 CPU 对 I/O 的干预，但当主机所配置的外设很多时，CPU 的负担仍然很重。为此，在 CPU 和设备控制器之间又增设了 I/O 通道(I/O Channel)。实际上是一种特殊的处理机。</li></ul></li><li><p>通道类型</p><ul><li>字节多路通道： <ul><li>这是一种按<strong>字节交叉方式</strong>工作的通道。它通常都含有许多<strong>非分配型子通道</strong>，其数量可从几十到数百个，每一个子通道连接一台 I/O 设备，并控制该设备的 I/O 操作。这些子通道按时间片轮转方式共享主通道。 字节多路通道</li></ul></li><li>数组选择通道(Block Selector Channel)</li><li>字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。可以连接多台高速设备，但由于它只有一个分配型子通道，在一段时间内只能执行一道通道程序，所以<strong>通道利用率低</strong>。</li><li>数组多路通道(Block Multiplexor Channel) <ul><li>数组选择通道虽有很高的传输速率，但它却每次<strong>只允许一个设备传输数据</strong>。数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并行操作的优点相结合而形成的一种新通道。</li></ul></li></ul></li><li><p>“瓶颈” 问题</p><ul><li><p>由于通道价格昂贵，致使机器中所设置的通道数量势必较少，这往往又使它成了 I/O 的瓶颈，进而造成整个系统吞吐量的下降</p><ul><li><p>单通路 I/O 系统</p><p><img src="https://img-blog.csdnimg.cn/9b6ffafb9e0942cca6f41e32162e8496.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>多通路 I/O 系统</p><p><img src="https://img-blog.csdnimg.cn/551019428a644c038626d78d34391462.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li></ul></li></ul><h3 id="_3-中断机构和中断处理程序" tabindex="-1"><a class="header-anchor" href="#_3-中断机构和中断处理程序" aria-hidden="true">#</a> 3 中断机构和中断处理程序</h3><ul><li>中断是多道程序得以实现的基础</li><li>进程切换通过中断完成</li><li>处理机提高利用率，实现 CPU 和 IO 并行也需要中断</li><li>中断程序是 IO 最底层，是基础</li></ul><h4 id="_3-1-中断简介" tabindex="-1"><a class="header-anchor" href="#_3-1-中断简介" aria-hidden="true">#</a> 3.1 中断简介</h4><ul><li>中断和陷入 <ul><li>中断：由外部设备引起</li><li>陷入：由内部事件引起</li></ul></li><li>中断向量表和中断优先级 <ul><li>中断向量表 <ul><li>OS 每个中断都配有中断号和中断处理程序</li><li>ISR 在内存的首地址为中断向量</li><li>系统所有的中断向量在一起构成的表称为中断向量表</li></ul></li><li>中断优先级 <ul><li>系统根据引起中断事件的重要性和紧迫程度，硬件将中断源分为若干个级别</li></ul></li></ul></li><li>对多中断源的处理方式 <ul><li>屏蔽中断（禁止） <ul><li>当处理机正在处理一个中断时，将屏蔽所有的中断，即处理机对任何新到的中断请求，都暂时不与理睬，而让它们等待。</li></ul></li><li>嵌套中断 <ul><li>当同时有多个不同优先级的中断请求时，CPU 优先响应最高优先级的中断请求。</li><li>高优先级的中断请求可以抢占正在运行的低优先级中断的处理机。</li></ul></li></ul></li></ul><h4 id="_3-2-中断处理程序" tabindex="-1"><a class="header-anchor" href="#_3-2-中断处理程序" aria-hidden="true">#</a> 3.2 中断处理程序</h4><ul><li>测定是否有未响应的中断信号</li><li>保护被中断进程的 CPU 环境</li><li>转入相应的设备处理程序</li><li>中断处理</li><li>回复 CPU 的现场并退出中断。</li><li>此刻是否回返回得到被中断的进程，取决于两个因素： <ul><li>本中断是否用了屏蔽（禁止）中断方式，若是，就会返回被中断的进程</li><li>嵌套中断。如果没有优先级更高的中断请求 I/O，在中断完成后，仍会返回被中断的进程，反之系统处理更高的中断请求</li></ul></li></ul><h3 id="_4-设备驱动系统" tabindex="-1"><a class="header-anchor" href="#_4-设备驱动系统" aria-hidden="true">#</a> 4 设备驱动系统</h3><h4 id="_4-1-设备驱动程序的概述" tabindex="-1"><a class="header-anchor" href="#_4-1-设备驱动程序的概述" aria-hidden="true">#</a> 4.1 设备驱动程序的概述</h4><ul><li>设备驱动程序的功能 <ul><li>接收由与设备无关的<strong>软件发来的命令和参数</strong>，并将命令中的抽象要求转换为与设备相关的<strong>低层操作序列</strong></li><li>检查用户 I/O 请求的合法性，了解 I/O 设备的工作状态，传递与 I/O 设备操作有关的参数，设置设备的工作方式</li><li>发出 I/O 命令，若设备空闲，立即启动 I/O 设备，完成指定的 I/O 操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待</li><li>及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理</li></ul></li><li>设备驱动程序的特点 <ul><li>驱动程序是实现在与设备无关的软件和设备控制器之间通信和转换的程序</li><li>驱动程序与设备控制器以及 I/O 设备的硬件特性紧密相关，对于不同类型的设备，应配置不同的驱动程序</li><li>驱动程序与 I/O 设备所采用的 I/O 控制方式紧密相关，常用的 I/O 控制方式是中断驱动和 DMA 方式</li><li>由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。目前有很多驱动程序的基本部分已经固化在 ROM 中</li><li>驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用</li></ul></li><li>设备处理方式 <ul><li>为每一类设备设置一个进程，专门用于执行这类设备的 I/O 操作</li><li>在整个系统中设置一个 I/0 进程，专门用于执行系统中所有各类设备的 I/O 操作。也可以设置一个输入进程和一个输出进程，分别处理系统中的输入或输出操作。</li><li>不设置专门的设备进程，而只为各类设备相应的设备驱动程序，供用户或系统进程调用</li></ul></li></ul><h4 id="_4-2-设备驱动程序的处理过程" tabindex="-1"><a class="header-anchor" href="#_4-2-设备驱动程序的处理过程" aria-hidden="true">#</a> 4.2 设备驱动程序的处理过程</h4><ul><li>将抽象要求转换为具体要求</li><li>对服务请求进行校验</li><li>检查设备状态</li><li>传送必要的参数</li><li>启动 I/O 设备</li></ul><h4 id="_4-3-对-i-o-设备的控制方式" tabindex="-1"><a class="header-anchor" href="#_4-3-对-i-o-设备的控制方式" aria-hidden="true">#</a> 4.3 对 I/O 设备的控制方式</h4><ul><li><p>核心思想：把 CPU 从 IO 事务脱离出来</p></li><li><p>使用轮询的可编程 I/O 方式</p><ul><li>设置有状态寄存位 busy 0 表示空闲 1 表示忙碌</li><li>实现简单，但是会忙等待（做无用功）</li></ul></li><li><p>使用中断的可编程 I/O 方式</p><ul><li>CPU 发出指令后，继续原有的任务</li><li>设备控制器按照要求去控制制定的 IO 设备</li><li>完成后设备驱动器向 CPU 发出中断</li><li>外设是主动地，实时性好</li></ul></li><li><p>直接存储器访问方式</p><ul><li>传输单位是数据块</li><li>直接在设备和内存交换，不需要 CPU</li><li>仅在开始和结束后需要 CPU</li></ul></li><li><p>I/O 通道控制方式</p><ul><li>把对一个数据块的读（或写）为单位的干预，减少为一组数据块的读（写）及有关的控制和管理。</li><li>通道程序：通道是通过执行通道程序并与设备控制器共同实现对 I/O 设备的控制的。通道程序是由一系列通道指令(或称为通道命令)所构成的 <ul><li>操作码：它规定了指令所执行的操作，如读、写控制等操作</li><li>内存地址：标明字符送入内存（读操作）和从内存取出（写操作）的时的内存首地址</li><li>计数：表示本条指令所要读（或写）数据的字节数</li><li>通道程序结束位 P：用于表示通道程序是否结束。P=1 表示本指令是通道程序的最后一条指令</li><li>记录结束标志 R：R=0 表示本通道与下一条指令所处理的数据是同属于一个记录：R=1 表示这是处理某记录的最后一条指令</li></ul></li></ul></li></ul><h3 id="_5-与设备无关的-i-o-软件" tabindex="-1"><a class="header-anchor" href="#_5-与设备无关的-i-o-软件" aria-hidden="true">#</a> 5 与设备无关的 I/O 软件</h3><h4 id="_5-1-与设备无关软件的基本概念" tabindex="-1"><a class="header-anchor" href="#_5-1-与设备无关软件的基本概念" aria-hidden="true">#</a> 5.1 与设备无关软件的基本概念</h4><ul><li>与物理设备名使用设备 <ul><li>在早期 OS 中，应用程序在使用 I/O 设备时，都使用设备的物理名称，这使应用程序与系统中的物理设备直接相关</li></ul></li><li>引入了逻辑设备名 <ul><li>为了实现与设备的无关性而引入了逻辑设备和物理设备两个概念。逻辑设备是抽象的设备名</li></ul></li><li>逻辑设备名称到物理设备名称的转换 <ul><li>在应用程序中，用逻辑设备名称使用设备虽然方便了用户，但系统却只识别物理设备名称，因此在实际执行时，还必须使用物理名称。为此，在系统中，必须具有将逻辑设备名称转换为某物理设备名称的功能</li></ul></li></ul><h4 id="_5-2-与设备无关的软件" tabindex="-1"><a class="header-anchor" href="#_5-2-与设备无关的软件" aria-hidden="true">#</a> 5.2 与设备无关的软件</h4><ul><li>设备驱动程序的统一接口</li><li>缓冲管理</li><li>差错控制</li><li>对独立设备的分配与回收</li><li>独立于设备的逻辑数据块</li></ul><h4 id="_5-3-设备分配" tabindex="-1"><a class="header-anchor" href="#_5-3-设备分配" aria-hidden="true">#</a> 5.3 设备分配</h4><ul><li>设备分配中的数据结构 <ul><li>设备控制表 DCT</li><li>控制器控制表 4++</li><li>通道控制表</li><li>系统设备表</li></ul></li><li>设备分配时应考虑的因素 <ul><li>设备的固有属性 <ul><li>独占设备的分配策略</li><li>共享设备的分配策略</li><li>虚拟设备的分配策略</li></ul></li><li>设备分配算法 <ul><li>先来先服务</li><li>优先级高者优先</li></ul></li><li>设备分配中的安全性 <ul><li>安全分配方式：不会死锁</li><li>不安全分配方式：有请求与保持条件，可能死锁</li></ul></li></ul></li><li>独占设备的分配程序 <ul><li>分配设备</li><li>分配控制器</li><li>分配通道</li></ul></li></ul><h4 id="_5-4-逻辑设备名到物理设备名映射的实现" tabindex="-1"><a class="header-anchor" href="#_5-4-逻辑设备名到物理设备名映射的实现" aria-hidden="true">#</a> 5.4 逻辑设备名到物理设备名映射的实现</h4><ul><li>逻辑设备表 LUT <ul><li>逻辑设备名</li><li>物理设备名</li><li>设备驱动程序的入口地址</li></ul></li><li>逻辑设备表的设置问题 <ul><li>在整个系统中只设置一张 LUT</li><li>不允许有相同的逻辑设备名</li><li>为每个用户设置一张 LUT <ul><li>表项有逻辑设备名和系统设备表</li></ul></li></ul></li></ul><h3 id="_6-用户层的-i-o-软件" tabindex="-1"><a class="header-anchor" href="#_6-用户层的-i-o-软件" aria-hidden="true">#</a> 6 用户层的 I/O 软件</h3><h4 id="_6-1-系统调用与库函数" tabindex="-1"><a class="header-anchor" href="#_6-1-系统调用与库函数" aria-hidden="true">#</a> 6.1 系统调用与库函数</h4><ul><li>系统调用 <ul><li>不允许用户直接调用核心态，通过系统调用获取 OS 服务</li></ul></li><li>库函数 <ul><li>对系统调用封装的函数</li></ul></li></ul><h4 id="_6-2-假脱机系统" tabindex="-1"><a class="header-anchor" href="#_6-2-假脱机系统" aria-hidden="true">#</a> 6.2 假脱机系统</h4><ul><li>假脱机技术 <ul><li>利用专门的外围控制机，先将<strong>低速 I/O 设备上的数据传送到高速磁盘上</strong>，或者相反。这样当处理机需要输入数据时，便可以<strong>直接从磁盘中读取数据</strong>，极大地提高了输入速度。反之，在处理机需要输出数据时，也可以很快的速度把数据先输出到磁盘上，处理机便可去做自己的事情。</li></ul></li><li>SPOOLing 的组成 <ul><li>SPOOLing 技术是对脱机输入/输出系统的模拟</li><li>输入井和输出井</li><li>这是在磁盘上开辟出来的两个存储区域。输入/输出井中的数据一般以文件的形式组织管理，这些文件叫井文件</li><li>输入缓冲区和输出缓冲区 <ul><li>这是在内存中开辟的两个缓冲区，用于缓和 CPU 和磁盘之间的矛盾。</li></ul></li><li>输入进程和输出进程</li><li>井管理程序</li></ul></li><li>SPOOLing 系统的特点 <ul><li>提高了 I/O 的速度</li><li>将独占设备改造为共享设备</li><li>实现了虚拟设备功能</li></ul></li><li>假脱机打印机系统 <ul><li>磁盘缓冲区</li><li>打印缓冲区</li><li>假脱机管理进程和假脱机打印进程</li></ul></li><li>守护进程</li></ul><h3 id="_7-缓冲区管理" tabindex="-1"><a class="header-anchor" href="#_7-缓冲区管理" aria-hidden="true">#</a> 7 缓冲区管理</h3><h4 id="_7-1-缓冲的引入" tabindex="-1"><a class="header-anchor" href="#_7-1-缓冲的引入" aria-hidden="true">#</a> 7.1 缓冲的引入</h4><ul><li><p>缓解 CPU 与 IO 设备速度不匹配</p></li><li><p>缓和 CPU 与 I/O 设备间速度不匹配的矛盾</p></li><li><p>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制</p></li><li><p>解决数据粒度不匹配的问题</p></li><li><p>提高 CPU 和 I/O 设备之间的并行性</p></li></ul><h4 id="_7-2-单缓存区和双缓存区" tabindex="-1"><a class="header-anchor" href="#_7-2-单缓存区和双缓存区" aria-hidden="true">#</a> 7.2 单缓存区和双缓存区</h4><ul><li><p>单缓存区</p><p><img src="https://img-blog.csdnimg.cn/a8be661fbc404e9fa81e929d80421696.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>双缓存区</p><p><img src="https://img-blog.csdnimg.cn/b8d333e6ba714882a37ac7346b3606e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h4 id="_7-3-环形缓冲区" tabindex="-1"><a class="header-anchor" href="#_7-3-环形缓冲区" aria-hidden="true">#</a> 7.3 环形缓冲区</h4><ul><li><p>环形缓冲区的组成</p><ul><li><p>多个缓冲区：每个缓冲区的大小相同</p><p><img src="https://img-blog.csdnimg.cn/d00cc917c688400bbed9785d9978a8c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li><li><p>环形缓冲区的使用</p><ul><li>计算进程和输入进程可利用两个过程来使用环形缓冲区：</li></ul></li><li><p>进程之间的同步问题</p><ul><li>使用输入循环缓冲，可使输入过程和计算过程并行执行</li><li>Nexti 指针追赶上 Nextg 指针：空闲缓冲区用完，输入进程阻塞</li><li>Nextg 指针追赶上 Nexti 指针：满缓冲区用完，计算进程阻塞</li></ul></li></ul><h4 id="_7-4-缓冲池" tabindex="-1"><a class="header-anchor" href="#_7-4-缓冲池" aria-hidden="true">#</a> 7.4 缓冲池</h4><ul><li>缓冲池的组成 <ul><li>三个队列： <ul><li>空白缓冲队列 emq</li><li>输入队列 inq</li><li>输出队列 outq</li></ul></li><li>四个工作缓冲区： <ul><li>用于收容输入数据的工作缓冲区</li><li>用于提取输入数据的工作缓冲区</li><li>用于收容输出数据的工作缓冲区</li><li>用于提取输出数据的工作缓冲区</li></ul></li></ul></li><li>Getbuf 过程和 Putbuf 过程</li><li>缓冲区的工作方式 <ul><li>收容输入：把设备输入的数据放在缓冲区中</li><li>提取输入：把缓冲区的数据交给用户程序处理</li><li>收容输出：把用户程序处理完的数据放在缓冲区中</li><li>提取输出</li></ul></li></ul><h3 id="_8-磁盘存储器的性能和调度" tabindex="-1"><a class="header-anchor" href="#_8-磁盘存储器的性能和调度" aria-hidden="true">#</a> 8 磁盘存储器的性能和调度</h3><h4 id="_8-1-磁盘性能" tabindex="-1"><a class="header-anchor" href="#_8-1-磁盘性能" aria-hidden="true">#</a> 8.1 磁盘性能</h4><ul><li>数据的组织和格式</li><li>磁盘类型</li><li>磁盘访问时间 <ul><li>寻道时间 Ts ：指的是把<strong>读写磁头移动到要求的磁道位置所需要的时间</strong>。这个时间除跨越 n 条磁道的时间外，还包括启动磁臂的时间 s，即：Ts = m * n + s。m 是与磁盘驱动器速度有关的常数，约为 0.2ms，磁臂的启动时间约为 2ms。</li><li>旋转延迟 Tr ：指的是在<strong>磁头到达所要求的磁道位置后，等待所要求的扇面旋转到磁头下方的平均时间</strong>。</li><li>传输时间 Tt ：从磁盘读出或向磁盘写入数据所经历的时间</li></ul></li></ul><h4 id="_8-2-早期的磁盘调度算法-减少寻道时间" tabindex="-1"><a class="header-anchor" href="#_8-2-早期的磁盘调度算法-减少寻道时间" aria-hidden="true">#</a> 8.2 早期的磁盘调度算法（减少寻道时间）</h4><ul><li><p>先来先服务（FCFS）</p><ul><li><p><strong>根据进程请求访问磁盘的先后顺序进行调度。</strong></p></li><li><p>优点：<strong>公平</strong>；如果请求访问的磁道比较集中的话，算法性能还算过的去</p></li><li><p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，<strong>寻道时间长</strong>。</p><p><img src="https://img-blog.csdnimg.cn/cf188044bdb1479bbbe1365bbee903af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYmZob25vcg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p></li></ul></li><li><p>最短寻道时间优先（SSTF）</p><ul><li><p><strong>SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</strong></p></li><li><p>优点：<strong>性能较好，平均寻道时间短</strong></p></li><li><p>缺点：<strong>可能产生“饥饿”现象</strong></p></li><li><p><strong>产生饥饿的原因在于：磁头在一个小区域内来回来去地移动</strong></p><p><img src="https://img-blog.csdnimg.cn/57f6275d2f3f4b44838ffe525d1d4b7a.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="_8-3-基于扫描的磁盘调度算法" tabindex="-1"><a class="header-anchor" href="#_8-3-基于扫描的磁盘调度算法" aria-hidden="true">#</a> 8.3 基于扫描的磁盘调度算法</h4><ul><li><p>扫描（SCAN）算法</p><ul><li><p><strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong> 。这就是**扫描算法（SCAN）**的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p></li><li><p>优点：<strong>性能较好，平均寻道时间较短，不会产生饥饿现象</strong></p></li><li><p>缺点：</p><ul><li><strong>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了 184 号磁道的访问请求之后就不需要再往右移动磁头了。</strong></li><li>SCAN 算法对于各个位置磁道的响应频率不平均**</li></ul><p><img src="https://img-blog.csdnimg.cn/a0071e18aa3e4952b586e1e322eacc54.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li><li><p>循环扫描（CSCAN）算法</p><ul><li><p>定只有磁头朝某个特定方向移动时才处理磁道访问请求，而 <strong>返回时直接快速移动至起始端而不处理任何请求。</strong></p></li><li><p>优点：比起 SCAN 来，对于各个位置磁道的响应频率很平均。</p></li><li><p>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了 184 号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到 18 号磁道即可，不需要返回到最边缘的磁道。另外，比起 SCAN 算法来，平均寻道时间更长。</p><p><img src="https://img-blog.csdnimg.cn/e7e205d13b83444ebd1e570990675e30.png#pic_center" alt="在这里插入图片描述"></p></li></ul></li><li><p>NStepSCAN 和 FSCAN 算法</p><ul><li>反复对某一个磁道进行操作称为<strong>磁臂黏着</strong></li><li>NStepSCAN：将磁盘请求分为若干队列，根据 FCFS 调度队列，队列内部采用 SCAN 算法，新请求放到新队列</li><li>FSCAN：将请求分为两个队列 <ul><li>当前请求按照 SCAN 算法处理</li><li>新的请求放入等待队列</li></ul></li></ul></li></ul><h2 id="第七章-文件管理" tabindex="-1"><a class="header-anchor" href="#第七章-文件管理" aria-hidden="true">#</a> 第七章---文件管理</h2><h3 id="_1-文件和文件系统" tabindex="-1"><a class="header-anchor" href="#_1-文件和文件系统" aria-hidden="true">#</a> 1 文件和文件系统</h3><ul><li>文件系统的管理功能是将其管理的程序和数据通过组织为一系列文件的方式实现</li></ul><h4 id="_1-1-数据项、记录、文件" tabindex="-1"><a class="header-anchor" href="#_1-1-数据项、记录、文件" aria-hidden="true">#</a> 1.1 数据项、记录、文件</h4><ol><li>数据项 <ol><li>基本数据项：用于描述一个对象的某种属性的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据</li><li>组合数据项：由多个基本数据项组成。</li></ol></li><li>记录：记录是一组相关的数据项的集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域</li><li>文件 <ol><li>文件属性 <ul><li>文件类型</li><li>文件长度</li><li>文件的物理位置</li><li>文件的建立时间</li></ul></li></ol></li></ol><h4 id="_1-2-文件名和类型" tabindex="-1"><a class="header-anchor" href="#_1-2-文件名和类型" aria-hidden="true">#</a> 1.2 文件名和类型</h4><ul><li>文件名和扩展名 <ul><li>在不同的系统中，对文件名的规定是不同的，在一些老的系统中，名字的长度受到限制。</li><li>扩展名是添加在文件后面的若干附加字符，有称为后缀名，用于指示文件的类型。</li></ul></li><li>文件类型 <ul><li>按文件的性质和用途分类 <ul><li>系统文件：系统软件构成的文件，如内核，系统应用程序，数据；只允许用户执行，不能读写和修改</li><li>用户文件：由用户建立的文件，如源程序、目标程序和数据文件等；用户将这些文件托给系统保管；只允许文件所有者和所有者授权用户使用</li><li>库文件：标准子例程及常用的例程构成的文件。这类文件允许用户调用，但不允许用户修改</li></ul></li><li>按文件中数据的形式分类 <ul><li>源文件：由源程序和数据构成的文件。通常由终端或输入设备输入的源程序和数据所形成的文件都属于源文件</li><li>目标文件：把源程序经过相应语言的编译程序编译过，但尚未经过链接程序链接的目标代码所构成的文件。它属于二进制文件。通常，目标文件所使用的后缀名是“.obj”</li><li>可执行文件：把编译后所产生的目标代码再经过链接程序链接后所形成的文件</li></ul></li><li>按存取控制属性分类 <ul><li>只执行文件：只允许被核准的用户调用执行，既不允许读，更不允许写</li><li>只读文件：只允许文件主及被核准的用户去读，但不允许写</li><li>读写文件：允许文件主和被核准的用户去读或写的文件</li></ul></li><li>按照组织形式和处理方式 <ul><li>普通文件</li><li>目录文件</li><li>特殊文件</li></ul></li></ul></li></ul><h4 id="_1-3-文件系统的层次结构" tabindex="-1"><a class="header-anchor" href="#_1-3-文件系统的层次结构" aria-hidden="true">#</a> 1.3 文件系统的层次结构</h4><ul><li><p>件系统的模型可以分为三个层次：最底层是对象及其属性，中间层是对对象进行操纵和管理的软件集合，最高层是文件系统提供给用户的接口</p><p><img src="https://img-blog.csdnimg.cn/3ecd1c384d5c48c2874f8c85ef08983b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>对象及其属性</p><ul><li>文件</li><li>目录 ：方便对文件进行检索和读取</li><li>磁盘存储空间</li></ul></li><li><p>对对象操作和管理的软件集合</p><ul><li>对文件存储空间的管理</li><li>对文件目录的管理</li><li>用于将文件的逻辑地址转换为物理地址的机制</li><li>对文件读和写的管理</li><li>对文件的共享与保护等功能</li><li>把与文件系统有关的软件分为四个层次 <ul><li>I/O 控制层：文件系统的最低层，主要由磁盘驱动程序等组成，称为设备驱动程序层</li><li>基本文件系统层：主要用于处理内存与磁盘之间数据块的交换</li><li>基本 I/O 管理程序：该层用于完成与磁盘 I/O 有关的事务</li><li>逻辑文件系统：用于处理与记录和文件相关的操作</li></ul></li></ul></li><li><p>文件系统的接口</p><ul><li>命令接口：是指作为用户与文件系统交互的接口，用户可通过键盘终端键入命令取得文件系统的服务</li><li>程序接口：是指作为用户程序与文件系统的接口，用户程序可通过系统调用取得文件系统的服务</li></ul></li></ul><h4 id="_1-4-文件操作" tabindex="-1"><a class="header-anchor" href="#_1-4-文件操作" aria-hidden="true">#</a> 1.4 文件操作</h4><ul><li>最基本的操作 <ul><li>创建文件</li><li>删除文件</li><li>读文件</li><li>写文件</li><li>设置文件的读/写的位置</li></ul></li><li>文件的打开和关闭操作 <ul><li>当用户要求对一个文件实施多次读/写操作时，每次都要从检索目录开始，为了避免多次重复检索目录，在大多数 OS 中引入了&quot;打开&quot;这一文件系统调用，当用户第一次请求对某文件进行操作时，须先利用 open 系统调用将该文件打开。</li></ul></li><li>其他文件操作 <ul><li>常用的一类是有关对文件属性的操作，即允许用户直接设置和获取文件的属性</li></ul></li></ul><h3 id="_2-文件的逻辑结构" tabindex="-1"><a class="header-anchor" href="#_2-文件的逻辑结构" aria-hidden="true">#</a> 2 文件的逻辑结构</h3><h4 id="_2-1-文件逻辑结构的类型" tabindex="-1"><a class="header-anchor" href="#_2-1-文件逻辑结构的类型" aria-hidden="true">#</a> 2.1 文件逻辑结构的类型</h4><ul><li>是否有结构，分为两类： <ul><li>有结构文件：这是指由一个以上的记录构成的文件，也称记录式文件 <ul><li>定长记录：文件中所有记录的长度都是相同的，个数据项都处在记录中相同的位置，具有相同的顺序和长度。</li><li>优点：有效提高检索记录的速度和效率，方便对文件进行处理和修改</li><li>变长记录：文件中各记录的长度不相同，产生边长记录的原因可能是由于一个记录中所包含数据项数目并不相同。 <ul><li>记录的检索速度慢，不方便对文件进行处理和修改</li></ul></li></ul></li><li>无结构文件：这是指由字符流构成的文件，也称流式文件</li></ul></li><li>从文件的组织方式来分 <ul><li>顺序文件</li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul><h4 id="_2-2-顺序文件" tabindex="-1"><a class="header-anchor" href="#_2-2-顺序文件" aria-hidden="true">#</a> 2.2 顺序文件</h4><ul><li>顺序文件的排列方式 <ul><li>串结构 <ul><li>按照存入时间的先后进行排序，各个记录之间的顺序与关键字无关。对文件进行检索的时候，每次都要从头开始，逐个记录</li></ul></li><li>顺序结构 <ul><li>用户指定哪一个字段作为关键字。优点：提高检索效率</li></ul></li></ul></li><li>优点：① 存取效率高</li><li>缺点：① 查找性能差 ② 增加删除困难</li></ul><h4 id="_2-3-记录寻址" tabindex="-1"><a class="header-anchor" href="#_2-3-记录寻址" aria-hidden="true">#</a> 2.3 记录寻址</h4><ul><li>隐式寻址方式 <ul><li>对于定长的顺序文件，如果已知当前记录的逻辑地址，很容易确定下一个记录的逻辑地址。</li></ul></li><li>显式寻址方式</li><li>用于对定长记录的文件实现直接或随机访问</li></ul><h4 id="_2-4-索引文件" tabindex="-1"><a class="header-anchor" href="#_2-4-索引文件" aria-hidden="true">#</a> 2.4 索引文件</h4><ul><li><p>按关键字建立索引</p><p><img src="https://img-blog.csdnimg.cn/2b0a622f3ca34685855fed0148cae41f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>具有多个索引表的索引文件</p><p><img src="https://img-blog.csdnimg.cn/2208be5bcf414ca9a1330c0919aec751.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h4 id="_2-5-索引顺序文件" tabindex="-1"><a class="header-anchor" href="#_2-5-索引顺序文件" aria-hidden="true">#</a> 2.5 索引顺序文件</h4><ul><li><p>索引顺序文件的特征</p><ul><li>克服变长记录的顺序文件不能随机访问，以及不便记录的删除和插入的缺点</li><li>两个新特征；① 引入文件索引表 ② 增加溢出文件</li></ul></li><li><p>一级索引顺序文件</p><p><img src="https://img-blog.csdnimg.cn/27ca437fa0564a4797f6745d9dab98e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>两级索引文件</p></li></ul><h4 id="_2-6-直接文件和哈希文件" tabindex="-1"><a class="header-anchor" href="#_2-6-直接文件和哈希文件" aria-hidden="true">#</a> 2.6 直接文件和哈希文件</h4><ul><li>直接文件：对于直接文件，则根据给定的记录键值，直接获得指定记录的物理地址，换言之，<strong>记录键值本身就决定了记录的物理地址</strong>，这种由记录键值到记录物理地址的转换被称为键值转换。</li><li>哈希文件：<strong>利用 Hash 函数可将记录键值转换为相应记录的地址</strong>，为了能实现文件存储空间的动态分配，通常由 Hash 函数所求得的并非是相应记录的地址，而是指向一目录表相应表目的指针，该表目的内容指向相应记录所在的物理块。</li></ul><h3 id="_3-文件目录" tabindex="-1"><a class="header-anchor" href="#_3-文件目录" aria-hidden="true">#</a> 3 文件目录</h3><ul><li><strong>文件目录也是一种数据结构，用于标识系统中的文件及其物理地址，供检索时使用</strong><ul><li>实现按名存取</li><li>提高对目录检索速度</li><li>文件共享</li><li>允许文件重名</li></ul></li></ul><h4 id="_3-1-文件控制块" tabindex="-1"><a class="header-anchor" href="#_3-1-文件控制块" aria-hidden="true">#</a> 3.1 文件控制块</h4><ul><li>基本信息 <ul><li>文件名</li><li>文件物理位置</li><li>文件逻辑结构</li><li>文件物理结构</li></ul></li><li>存取控制信息：包括文件主的存取权限、核准用户的存取权限及一般用户的存取权限</li><li>包括文件的建立日期和时间、文件上一次修改的日期和时间及当前使用信息使用信息：</li></ul><h4 id="_3-2-索引结点" tabindex="-1"><a class="header-anchor" href="#_3-2-索引结点" aria-hidden="true">#</a> 3.2 索引结点</h4><ul><li>索引结点的引入 <ul><li>文件目录可能要占用大量的盘块</li><li>用文件名进行匹配</li></ul></li><li>磁盘索引结点 <ul><li><strong>每个文件都有唯一的磁盘索引结点</strong></li><li>文件主标识符</li><li>文件类型</li><li>文件存取权限</li><li>文件物理地址</li><li>文件长度</li><li>文件连接计数</li><li>文件存取时间</li></ul></li><li>内存索引结点 <ul><li>索引结点编号</li><li>状态</li><li>访问计数</li><li>文件所属文件系统的逻辑设备号</li><li>链接指针</li></ul></li></ul><h4 id="_3-3-目录结构" tabindex="-1"><a class="header-anchor" href="#_3-3-目录结构" aria-hidden="true">#</a> 3.3 目录结构</h4><ul><li><p>单级目录结构</p><ul><li><p>优点：是简单并且能够实现目录管理的基本功能-按名存取</p></li><li><p>缺点：查找速度慢：查找一个目录项要花费较多的时间</p><p>② 不允许重名：在一个目录表中的所有文件，都不能与另一个文件有相同的名字，这是难以避免的</p><p>③ 不便于实现文件共享：每一个用户都有自己的名字空间或命名习惯，因此，应该允许不同用户使用不同的文件名来访问同一个文件</p></li></ul></li><li><p>两级目录结构</p><ul><li><p>提高了检索目录的速度：如果在主目录中有 n 个子目录，每个用户目录最多为 m 个目录项，则为查找一指定的目录项，最多只需要检索 n+m 个目录</p><p>② 在不同的用户目录中，可以使用相同的文件名：只要在用户自己的 UFD 中，每个文件名都是唯一的，不同用户可以有文件名相同的文件</p><p>③ 不同用户还可使用不同的文件名来访问系统中同一个共享文件：但在多个用户需要合作完成一个大任务时，不便于用户之间共享文件</p><p><img src="https://img-blog.csdnimg.cn/3a8d7d81e24449dfb95a354d0e58b2b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li></ul><h4 id="_3-4-树形目录结构" tabindex="-1"><a class="header-anchor" href="#_3-4-树形目录结构" aria-hidden="true">#</a> 3.4 树形目录结构</h4><ul><li><p>树形目录</p><p><img src="https://img-blog.csdnimg.cn/6fa08e47c7234a9e8a302fd3dd29308b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>路径名和当前目录</p><ul><li>系统中的每个文件都有唯一的路径名</li></ul></li><li><p>目录操作</p><ul><li>创建目录</li><li>删除目录 <ul><li>不删除非空目录</li><li>可删除非空目录</li></ul></li><li>改变目录</li><li>移动目录</li><li>链接操作</li><li>查找</li></ul></li></ul><h4 id="_3-5-目录查询技术" tabindex="-1"><a class="header-anchor" href="#_3-5-目录查询技术" aria-hidden="true">#</a> 3.5 目录查询技术</h4><ul><li><p>线性检索法</p><ul><li><p>在单级目录中，利用用户提供的文件名，用顺序查找法从文件目录中找到文件的目录项，在树形目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找，假定用户给定的文件路径名为/usr/ast/mbox</p><p><img src="https://img-blog.csdnimg.cn/dc3b5d40a7b448a1912ad016e75c86ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li><li><p>Hash 方法</p><ul><li>系统利用用户提供的文件名并将它转换为文件目录的索引值，再利用该索引值到目录中去查找，这将提高检索速度</li></ul></li></ul><h3 id="_4-文件共享" tabindex="-1"><a class="header-anchor" href="#_4-文件共享" aria-hidden="true">#</a> 4 文件共享</h3><h4 id="_4-1-基于无循环图实现文件共享—硬连接" tabindex="-1"><a class="header-anchor" href="#_4-1-基于无循环图实现文件共享—硬连接" aria-hidden="true">#</a> 4.1 基于无循环图实现文件共享—硬连接</h4><ul><li><p>有向无循环图</p><p><img src="https://img-blog.csdnimg.cn/aab853a34d6740baa3802c4c4333ff72.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>利用索引节点</p><p><img src="https://img-blog.csdnimg.cn/ef20d9691ddd4accbbf5c8ff05e6bd56.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h4 id="_4-2-利用符号链实现文件共享—软连接" tabindex="-1"><a class="header-anchor" href="#_4-2-利用符号链实现文件共享—软连接" aria-hidden="true">#</a> 4.2 利用符号链实现文件共享—软连接</h4><ul><li><p>利用符号链接的基本思想</p><p><img src="https://img-blog.csdnimg.cn/7f1e171570f549018cc2534b9ec42b92.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>如何利用符号链实现共享</p><ul><li>新文件中的路径名则只被看做是符号链，当用户 B 要访问被链接的文件 F 且正要读 LINK 类新文件时，操作系统根据新文件中的路径名去读该文件，从而实现了用户 B 对文件 F 的共享</li></ul></li><li><p>**总结：**硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享可以称为动态共享。</p></li></ul><h3 id="_5-文件保护" tabindex="-1"><a class="header-anchor" href="#_5-文件保护" aria-hidden="true">#</a> 5 文件保护</h3><ul><li>影响文件安全性的主要因素： <ul><li>人为因素 通过存取控制机制，防止由人为因素造成的文件不安全性</li><li>系统因素 采取系统容错技术，防止系统部分的故障造成的文件的不安全性</li><li>自然因素 建立后备系统，防止由自然因素所造成的不安全性</li></ul></li></ul><h4 id="_5-1-保护域" tabindex="-1"><a class="header-anchor" href="#_5-1-保护域" aria-hidden="true">#</a> 5.1 保护域</h4><ul><li>规定每一个进程仅能在保护域内执行操作，而且只允许进程访问它们具有访问权的对象</li><li>访问权：我们把一个进程能对某对象执行操作的权力称为访问权。</li><li>保护域：域是进程对一组对象访问权的集合，进程只能在指定域内执行操作。</li><li>进程和域间的静态联系 <ul><li>在进程和域之间可以一一对应，即一个进程只联系着一个域。这意味着，在进程的整个生命周期中，其可用的资源是固定的，我们把这种域称为“静态域”。</li></ul></li><li>进程和域间的动态联系 <ul><li>在进程与域间也可以是一对多的关系，即一个进程联系着多个域。在此情况下，可将进程的运行分为若干个阶段，每一个阶段联系着一个域，这样便可根据运行的实际需要来规定在进程运行的每个阶段中能访问的对象。</li></ul></li></ul><h4 id="_5-2-访问矩阵" tabindex="-1"><a class="header-anchor" href="#_5-2-访问矩阵" aria-hidden="true">#</a> 5.2 访问矩阵</h4><ul><li><p>访问矩阵中的行代表域，列代表对象，矩阵中的每一项是由一组访问权组成的。</p><p><img src="https://img-blog.csdnimg.cn/2fc8a3c3ff0b479980d496c3afd071f7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>具有切换权的访问矩阵</p><p><img src="https://img-blog.csdnimg.cn/cc8c31a8fb2d4559bc8e1a98d3b4473f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h4 id="_5-3-访问矩阵的修改" tabindex="-1"><a class="header-anchor" href="#_5-3-访问矩阵的修改" aria-hidden="true">#</a> 5.3 访问矩阵的修改</h4><ul><li><p>拷贝权</p><ul><li><p>凡是在访问权上加星号的，都表示运行的进程能将其对对象的访问权复制在任何域中对同一对象的访问权。</p><p><img src="https://img-blog.csdnimg.cn/19b38907ebf44e1ebf5fa8f6ee062929.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li><li><p>所有权</p><ul><li><p>将已有的访问权进行有控制的扩散，而且同样需要能增加某种访问权，或者能删除某种访问权</p><p><img src="https://img-blog.csdnimg.cn/f0aaa13d7fb247309fbbac6a5d8f579d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li><li><p>控制权</p><ul><li><p>控制权用于改变矩阵内同一行种的各项访问权，或用于改变某个领域中运行的进程对不同对象的访问权。</p><p><img src="https://img-blog.csdnimg.cn/34e110002bd14ac5b75c71433963df9b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul></li></ul><h3 id="_5-4-访问矩阵的实现" tabindex="-1"><a class="header-anchor" href="#_5-4-访问矩阵的实现" aria-hidden="true">#</a> 5.4 访问矩阵的实现</h3><ul><li><p>访问控制表</p><ul><li>指对访问矩阵按列划分，为每一列建立一张访问控制表 ACL</li><li>该表中已把矩阵中属于该列的所有空项删除，此时访问控制表是由一有序对（域，权集）所组成的。</li><li>域是一个抽象的概念，可用各种方式实现。最常见的一种情况是每一个用户是一个域，而对象是文件。</li></ul></li><li><p>访问权限表</p><p><img src="https://img-blog.csdnimg.cn/724f8a63990f4ffa989a55192d58e843.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YKy5aiH5ZGz55qE6I2J6I6T,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h2 id="第八章磁盘存储器的管理" tabindex="-1"><a class="header-anchor" href="#第八章磁盘存储器的管理" aria-hidden="true">#</a> 第八章磁盘存储器的管理</h2><h3 id="_1-外存的组织方式" tabindex="-1"><a class="header-anchor" href="#_1-外存的组织方式" aria-hidden="true">#</a> 1 外存的组织方式</h3><h4 id="_1-1-连续组织方式-分配连续空间-顺序式文件结构" tabindex="-1"><a class="header-anchor" href="#_1-1-连续组织方式-分配连续空间-顺序式文件结构" aria-hidden="true">#</a> 1.1 连续组织方式：分配连续空间，顺序式文件结构</h4><ul><li>每一个文件分配相邻盘块</li><li>逻辑文件按顺序记录到相邻盘块，叫做顺序文件</li><li>文件目录有首个盘块号和文件长度</li><li>优点：顺序访问容易，读写速度快</li><li>缺点： ① 会产生外存碎片。可紧凑法弥补，但需要额外的空间，和内存紧凑相比更花时间。 ② 创建文件时要给出文件大小；存储空间利用率不高，不利于文件的动态增加和修改；</li><li>适用于变化不大顺序访问的文件，在流行的 UNIX 系统中仍保留了连续文件结构。如对换区。</li></ul><h4 id="_1-2-链接组织方式-用指针将文件所有的磁块链接" tabindex="-1"><a class="header-anchor" href="#_1-2-链接组织方式-用指针将文件所有的磁块链接" aria-hidden="true">#</a> 1.2 链接组织方式：用指针将文件所有的磁块链接</h4><ul><li>隐式链接：文件目录有指向首尾盘块指针，中间含有下一个磁盘块信息 <ul><li>缺点：只适合顺序访问，可靠性差</li></ul></li><li>显式链接 <ul><li>将连接指针放入内存链接表中</li></ul></li></ul><h4 id="_1-3fat-技术" tabindex="-1"><a class="header-anchor" href="#_1-3fat-技术" aria-hidden="true">#</a> 1.3FAT 技术</h4><ul><li>文件卷 <ul><li>物理磁盘可以分为四个逻辑磁盘，卷=分区</li><li>卷可以单独使用</li></ul></li><li>FAT12 系统 <ul><li>以盘块为单位</li><li>有两个相同的文件分配表</li><li>每个表项占用 12 位，做都有 2^12 个盘块，一个盘块 521 字节，每个分区 2MB，磁盘最大 8MB</li><li>只支持短文件名 8+3</li><li>以簇为单位的 FAT12 <ul><li>簇就是一组相邻的扇区</li><li>以簇为单位分配</li><li>减少表项，减小访问开销，增加内碎片</li></ul></li></ul></li><li>FAT16 <ul><li>有 2^16 个表项一个磁盘分区最多 2^16 簇 每个簇可以有 2、4……64 个盘块</li><li>分区最大支持 2^16*64 * 521 =2GB</li></ul></li><li>FAT32 <ul><li>每个簇 32 位最大 2TB</li></ul></li><li>NTFS <ul><li>采用 64 位磁盘地址</li><li>簇作为单位分配回收，分配时不关心磁盘块大小</li><li>文件组织 <ul><li>以卷为单位，所有信息记录在一张主控文件表中</li><li>每个文件占一行，每行 1kb</li></ul></li></ul></li></ul><h4 id="_1-5-索引组织方式-文件采取索引组织方式" tabindex="-1"><a class="header-anchor" href="#_1-5-索引组织方式-文件采取索引组织方式" aria-hidden="true">#</a> 1.5 索引组织方式：文件采取索引组织方式</h4><ul><li>单级索引分配 <ul><li>分配一个索引块，记录所有的文件块，在表中记录索引快的位置</li></ul></li><li>多级索引分配 <ul><li>为了解决大型文件索引多的问题，为索引在建立一个索引</li></ul></li><li>增量式索引 <ul><li>小文件直接将地址放入 FCB，直接寻址</li><li>中等文件采取单级索引</li><li>大文件采取多级索引</li></ul></li></ul><h3 id="_2-存储空间的管理" tabindex="-1"><a class="header-anchor" href="#_2-存储空间的管理" aria-hidden="true">#</a> 2 存储空间的管理</h3><h4 id="_2-1-空闲表法" tabindex="-1"><a class="header-anchor" href="#_2-1-空闲表法" aria-hidden="true">#</a> 2.1 空闲表法</h4><ul><li><p>连续分配法</p></li><li><p>为所有的空闲区建立空闲表每个空闲区对用一个表项</p></li><li><p>空闲区按照盘号递增排序</p><p><img src="https://img-blog.csdnimg.cn/20181211131418864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5leUtLRQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>按照首次适应算法和最佳适应算法等分配</p></li></ul><h4 id="_2-2-空闲链表法" tabindex="-1"><a class="header-anchor" href="#_2-2-空闲链表法" aria-hidden="true">#</a> 2.2 空闲链表法</h4><ul><li>空闲盘块链：将磁盘上的所有空闲空间，以盘块为单位拉成一条链。 <ul><li>分配时将链首的分配给用户，回收时插入链尾</li></ul></li><li>空闲盘区链：将所有空闲盘区拉成一条链 <ul><li>每个盘区含有下一个盘区的指针</li><li>分配回收复杂</li></ul></li></ul><h4 id="_2-3-位示图法" tabindex="-1"><a class="header-anchor" href="#_2-3-位示图法" aria-hidden="true">#</a> 2.3 位示图法</h4><ul><li>利用二进制的一位来表示一个盘块的使用情况。</li><li>盘块号 = 列总数*（i-1）+ j;（注意下标 i，j 从 1 开始）</li><li>将回收盘块的盘块号转换成位示图中的行号和列号。 转换公式为：i=(盘块号-1)div 列数+1；j=(盘块号-1)mod 列数+1 Div 求商，mod 取余，公式中的 i、j 都是从 1 开始的</li></ul><h4 id="_2-4-成组链接法" tabindex="-1"><a class="header-anchor" href="#_2-4-成组链接法" aria-hidden="true">#</a> 2.4 成组链接法</h4><p><img src="https://img-blog.csdnimg.cn/20200613194213962.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTU0MTYzMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="_3-提高磁盘-i-o-速度的途径" tabindex="-1"><a class="header-anchor" href="#_3-提高磁盘-i-o-速度的途径" aria-hidden="true">#</a> 3. 提高磁盘 I/O 速度的途径</h3><h4 id="_3-1-磁盘高速缓存" tabindex="-1"><a class="header-anchor" href="#_3-1-磁盘高速缓存" aria-hidden="true">#</a> 3.1 磁盘高速缓存</h4><ul><li>在内存中为磁盘块设置的一个缓冲区，其中存放有磁盘中某些盘块的副本。</li><li>数据交付方式 <ul><li>数据交付：将缓存中的数据拷贝到工作区</li><li>指针交付：将数据的指针交给进程</li></ul></li><li>置换算法：LRU NRU LFU</li><li>周期性写回磁盘 <ul><li>将缓存写成 LRU 链表换出影响大或者不使用的元素</li><li>30s 会强制将修改的文件写回磁盘</li></ul></li></ul><h4 id="_3-2-提前读" tabindex="-1"><a class="header-anchor" href="#_3-2-提前读" aria-hidden="true">#</a> 3.2 提前读</h4><ul><li>在读当前盘块的同时，将下一个可能要访问到的盘块中的数据也读入缓冲区。</li></ul><h4 id="_3-3-延迟写" tabindex="-1"><a class="header-anchor" href="#_3-3-延迟写" aria-hidden="true">#</a> 3.3 延迟写</h4><ul><li>不立即将对应缓冲区中的数据写入磁盘，而只将它置上“延迟写”标志并挂到空闲缓冲队列的末尾。当该缓冲区移到空闲缓冲队列的首部，并作为空闲缓冲被分配出去时，才将缓冲区中的数据写入磁盘</li></ul><h4 id="_3-4-优化物理块布局" tabindex="-1"><a class="header-anchor" href="#_3-4-优化物理块布局" aria-hidden="true">#</a> 3.4 优化物理块布局</h4><h4 id="_3-5-虚拟盘-ram-盘" tabindex="-1"><a class="header-anchor" href="#_3-5-虚拟盘-ram-盘" aria-hidden="true">#</a> 3.5 虚拟盘（RAM 盘）</h4><ul><li>利用内存空间去仿真磁盘。只用来存放临时性文件。</li></ul><h4 id="_3-6-廉价磁盘冗余阵列-raid" tabindex="-1"><a class="header-anchor" href="#_3-6-廉价磁盘冗余阵列-raid" aria-hidden="true">#</a> 3.6 廉价磁盘冗余阵列（RAID）</h4></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: hu@seekhoo.cn">seekHoo</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.91a380bb.js" defer></script>
  </body>
</html>
